"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// packages/node/src/index.ts
var src_exports = {};
__export(src_exports, {
  NodeWatchService: () => NodeWatchService,
  createBaseNodeFs: () => createBaseNodeFs,
  createNodeFs: () => createNodeFs,
  default: () => src_default,
  nodeFs: () => nodeFs
});
module.exports = __toCommonJS(src_exports);

// packages/node/src/node-fs.ts
var import_node_fs2 = __toESM(require("node:fs"));
var import_node_path2 = __toESM(require("node:path"));
var import_node_process = require("node:process");
var import_node_util = require("node:util");
var import_utils2 = require("@file-services/utils");

// packages/node/src/watch-service.ts
var import_node_events = require("node:events");
var import_node_fs = require("node:fs");
var import_node_path = require("node:path");
var import_utils = require("@file-services/utils");
var { stat } = import_node_fs.promises;
var NodeWatchService = class {
  /**
   * Construct a new Node file system watch service
   */
  constructor(options) {
    /** user's subsribed global listeners */
    this.globalListeners = /* @__PURE__ */ new Set();
    /** all watched paths (including files inside watched directories) */
    this.watchedPaths = new import_utils.SetMultiMap();
    /** path to actual FSWatcher instance opened for it */
    this.fsWatchers = /* @__PURE__ */ new Map();
    /** path to its pending event (debounced watch event) */
    this.pendingEvents = /* @__PURE__ */ new Map();
    this.options = { persistent: true, debounceWait: 200, ...options };
  }
  async watchPath(path2, listener) {
    if (listener) {
      this.watchedPaths.add(path2, listener);
    }
    await this.ensureFsWatcher(path2);
  }
  async unwatchPath(path2, listener) {
    if (listener) {
      this.watchedPaths.delete(path2, listener);
    } else {
      this.watchedPaths.deleteKey(path2);
    }
    if (!this.watchedPaths.hasKey(path2)) {
      const fsWatcher = this.fsWatchers.get(path2);
      if (fsWatcher) {
        fsWatcher.close();
        this.fsWatchers.delete(path2);
        await (0, import_node_events.once)(fsWatcher, "close");
      }
    }
    const pendingEvent = this.pendingEvents.get(path2);
    if (pendingEvent) {
      clearTimeout(pendingEvent.timerId);
      this.pendingEvents.delete(path2);
    }
  }
  async unwatchAllPaths() {
    for (const watcher of this.fsWatchers.values()) {
      watcher.close();
    }
    for (const { timerId } of this.pendingEvents.values()) {
      clearTimeout(timerId);
    }
    const watcherCloseEvents = Array.from(this.fsWatchers.values(), (watcher) => (0, import_node_events.once)(watcher, "close"));
    this.pendingEvents.clear();
    this.fsWatchers.clear();
    this.watchedPaths.clear();
    await Promise.all(watcherCloseEvents);
  }
  addGlobalListener(listener) {
    this.globalListeners.add(listener);
  }
  removeGlobalListener(listener) {
    this.globalListeners.delete(listener);
  }
  clearGlobalListeners() {
    this.globalListeners.clear();
  }
  /**
   * Debounces watch events while retaining whether one of
   * them was a 'rename' event
   */
  onPathEvent(eventType, eventPath) {
    const pendingEvent = this.pendingEvents.get(eventPath);
    const timerId = setTimeout(() => {
      this.emitEvent(eventPath).catch((e) => this.onWatchError(e, eventPath));
    }, this.options.debounceWait);
    if (pendingEvent) {
      clearTimeout(pendingEvent.timerId);
      pendingEvent.renamed = pendingEvent.renamed || eventType === "rename";
      pendingEvent.timerId = timerId;
    } else {
      this.pendingEvents.set(eventPath, { renamed: eventType === "rename", timerId });
    }
  }
  async emitEvent(path2) {
    const pendingEvent = this.pendingEvents.get(path2);
    if (!pendingEvent) {
      return;
    }
    this.pendingEvents.delete(path2);
    const stats = await this.statSafe(path2);
    if (pendingEvent.renamed) {
      const existingWatcher = this.fsWatchers.get(path2);
      if (existingWatcher) {
        existingWatcher.close();
        this.fsWatchers.delete(path2);
        if (stats) {
          await this.ensureFsWatcher(path2, stats);
        }
      }
    }
    const watchEvent = { path: path2, stats };
    for (const listener of this.globalListeners) {
      listener(watchEvent);
    }
    const listeners = this.watchedPaths.get(path2);
    if (listeners) {
      for (const listener of listeners) {
        listener({ path: path2, stats });
      }
    }
  }
  async ensureFsWatcher(path2, stats) {
    if (this.fsWatchers.has(path2)) {
      return;
    }
    const pathStats = stats || await this.statSafe(path2);
    if (!pathStats) {
      throw new Error(`cannot watch non-existing path: ${path2}`);
    }
    const watchOptions = { persistent: this.options.persistent };
    if (pathStats.isFile()) {
      const fileWatcher = (0, import_node_fs.watch)(path2, watchOptions, (type) => this.onPathEvent(type, path2));
      fileWatcher.once("error", (e) => {
        this.onWatchError(e, path2);
      });
      this.fsWatchers.set(path2, fileWatcher);
    } else if (pathStats.isDirectory()) {
      const directoryWatcher = (0, import_node_fs.watch)(path2, watchOptions, (type, fileName) => {
        if (fileName !== null) {
          this.onDirectoryEvent(type, path2, fileName).catch((e) => {
            this.onWatchError(e, path2);
          });
        }
      });
      directoryWatcher.once("error", (e) => {
        this.onWatchError(e, path2);
      });
      this.fsWatchers.set(path2, directoryWatcher);
    } else {
      throw new Error(`${path2} does not point to a file or a directory`);
    }
  }
  onWatchError(_e, path2) {
    this.onPathEvent("rename", path2);
    const watcher = this.fsWatchers.get(path2);
    if (watcher) {
      watcher.close();
    }
  }
  async onDirectoryEvent(eventType, directoryPath, fileName) {
    const directoryStats = await this.statSafe(directoryPath);
    this.onPathEvent(eventType, directoryStats ? (0, import_node_path.join)(directoryPath, fileName) : directoryPath);
  }
  async statSafe(nodePath) {
    try {
      return await stat(nodePath);
    } catch {
      return null;
    }
  }
};

// packages/node/src/node-fs.ts
var caseSensitive = !import_node_fs2.default.existsSync(import_node_process.argv[0].toUpperCase());
var fsPromisesExists = (0, import_node_util.promisify)(import_node_fs2.default.exists);
function createNodeFs(options) {
  return (0, import_utils2.createFileSystem)(createBaseNodeFs(options));
}
function createBaseNodeFs(options) {
  return {
    ...import_node_path2.default,
    chdir: import_node_process.chdir,
    cwd: import_node_process.cwd,
    watchService: new NodeWatchService(options && options.watchOptions),
    caseSensitive,
    ...import_node_fs2.default,
    promises: {
      ...import_node_fs2.default.promises,
      exists: fsPromisesExists
    }
  };
}

// packages/node/src/index.ts
var nodeFs = createNodeFs();
var src_default = nodeFs;
//# sourceMappingURL=fs-node.cjs.map
