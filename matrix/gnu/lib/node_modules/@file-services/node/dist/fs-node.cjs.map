{
  "version": 3,
  "sources": ["../src/index.ts", "../src/node-fs.ts", "../src/watch-service.ts"],
  "sourcesContent": ["import { createNodeFs } from './node-fs';\nimport type { IFileSystem } from '@file-services/types';\n\nexport * from './node-fs';\nexport * from './watch-service';\n\nexport const nodeFs: IFileSystem = createNodeFs();\nexport default nodeFs;\n", "import fs from 'node:fs';\nimport path from 'node:path';\nimport { chdir, cwd, argv } from 'node:process';\nimport { promisify } from 'node:util';\n\nimport type { IBaseFileSystem, IFileSystem, IFileSystemPath } from '@file-services/types';\nimport { createFileSystem } from '@file-services/utils';\nimport { INodeWatchServiceOptions, NodeWatchService } from './watch-service';\n\nconst caseSensitive = !fs.existsSync(argv[0]!.toUpperCase());\nconst fsPromisesExists = promisify(fs.exists);\n\nexport interface ICreateNodeFsOptions {\n  watchOptions?: INodeWatchServiceOptions;\n}\n\nexport function createNodeFs(options?: ICreateNodeFsOptions): IFileSystem {\n  return createFileSystem(createBaseNodeFs(options));\n}\n\nexport function createBaseNodeFs(options?: ICreateNodeFsOptions): IBaseFileSystem {\n  return {\n    ...(path as IFileSystemPath),\n    chdir,\n    cwd,\n    watchService: new NodeWatchService(options && options.watchOptions),\n    caseSensitive,\n    ...fs,\n    promises: {\n      ...fs.promises,\n      exists: fsPromisesExists,\n    },\n  };\n}\n", "import { once } from 'node:events';\nimport { FSWatcher, promises as fsPromises, watch } from 'node:fs';\nimport { join } from 'node:path';\n\nimport type { IFileSystemStats, IWatchEvent, IWatchService, WatchEventListener } from '@file-services/types';\nimport { SetMultiMap } from '@file-services/utils';\n\nconst { stat } = fsPromises;\n\nexport interface INodeWatchServiceOptions {\n  /**\n   * Should fs watchers be persistent and keep the process open\n   * (until someone calls `unwatchAllPaths()`)\n   *\n   * @default true\n   */\n  persistent?: boolean;\n\n  /**\n   * How much time (in ms) to wait for next native watch event before\n   * emitting a service watch event\n   *\n   * @default 200\n   */\n  debounceWait?: number;\n}\n\ninterface IPendingEvent {\n  /* whether one of the raw fs events was 'rename' */\n  renamed: boolean;\n\n  /* id of the setTimeout call, for debouncing */\n  timerId: ReturnType<typeof setTimeout>;\n}\n\nexport class NodeWatchService implements IWatchService {\n  /** user's subsribed global listeners */\n  private globalListeners: Set<WatchEventListener> = new Set();\n\n  /** resolved options (default + user) */\n  private options: Required<INodeWatchServiceOptions>;\n\n  /** all watched paths (including files inside watched directories) */\n  private watchedPaths = new SetMultiMap<string, WatchEventListener>();\n\n  /** path to actual FSWatcher instance opened for it */\n  private fsWatchers = new Map<string, FSWatcher>();\n\n  /** path to its pending event (debounced watch event) */\n  private pendingEvents = new Map<string, IPendingEvent>();\n\n  /**\n   * Construct a new Node file system watch service\n   */\n  constructor(options?: INodeWatchServiceOptions) {\n    this.options = { persistent: true, debounceWait: 200, ...options };\n  }\n\n  public async watchPath(path: string, listener?: WatchEventListener): Promise<void> {\n    if (listener) {\n      this.watchedPaths.add(path, listener);\n    }\n    await this.ensureFsWatcher(path);\n  }\n\n  public async unwatchPath(path: string, listener?: WatchEventListener): Promise<void> {\n    if (listener) {\n      this.watchedPaths.delete(path, listener);\n    } else {\n      this.watchedPaths.deleteKey(path);\n    }\n\n    if (!this.watchedPaths.hasKey(path)) {\n      const fsWatcher = this.fsWatchers.get(path);\n      if (fsWatcher) {\n        fsWatcher.close();\n        this.fsWatchers.delete(path);\n        await once(fsWatcher, 'close');\n      }\n    }\n    const pendingEvent = this.pendingEvents.get(path);\n    if (pendingEvent) {\n      clearTimeout(pendingEvent.timerId);\n      this.pendingEvents.delete(path);\n    }\n  }\n\n  public async unwatchAllPaths(): Promise<void> {\n    for (const watcher of this.fsWatchers.values()) {\n      watcher.close();\n    }\n    for (const { timerId } of this.pendingEvents.values()) {\n      clearTimeout(timerId);\n    }\n    const watcherCloseEvents = Array.from(this.fsWatchers.values(), (watcher) => once(watcher, 'close'));\n    this.pendingEvents.clear();\n    this.fsWatchers.clear();\n    this.watchedPaths.clear();\n    await Promise.all(watcherCloseEvents);\n  }\n\n  public addGlobalListener(listener: WatchEventListener): void {\n    this.globalListeners.add(listener);\n  }\n\n  public removeGlobalListener(listener: WatchEventListener): void {\n    this.globalListeners.delete(listener);\n  }\n\n  public clearGlobalListeners(): void {\n    this.globalListeners.clear();\n  }\n\n  /**\n   * Debounces watch events while retaining whether one of\n   * them was a 'rename' event\n   */\n  private onPathEvent(eventType: string, eventPath: string) {\n    const pendingEvent = this.pendingEvents.get(eventPath);\n    const timerId = setTimeout(() => {\n      this.emitEvent(eventPath).catch((e) => this.onWatchError(e as Error, eventPath));\n    }, this.options.debounceWait);\n\n    if (pendingEvent) {\n      clearTimeout(pendingEvent.timerId);\n      pendingEvent.renamed = pendingEvent.renamed || eventType === 'rename';\n      pendingEvent.timerId = timerId;\n    } else {\n      this.pendingEvents.set(eventPath, { renamed: eventType === 'rename', timerId });\n    }\n  }\n\n  private async emitEvent(path: string): Promise<void> {\n    const pendingEvent = this.pendingEvents.get(path);\n    if (!pendingEvent) {\n      return;\n    }\n    this.pendingEvents.delete(path);\n\n    const stats = await this.statSafe(path);\n\n    if (pendingEvent.renamed) {\n      // if one of the bounced events was a rename, make sure to unwatch,\n      // as the underlying native inode is now different, and our watcher\n      // is not receiving events for the new one\n      const existingWatcher = this.fsWatchers.get(path);\n      if (existingWatcher) {\n        existingWatcher.close();\n        this.fsWatchers.delete(path);\n        // rewatch if path points to a new inode\n        if (stats) {\n          await this.ensureFsWatcher(path, stats);\n        }\n      }\n    }\n\n    const watchEvent: IWatchEvent = { path, stats };\n\n    // inform global listeners\n    for (const listener of this.globalListeners) {\n      listener(watchEvent);\n    }\n\n    // inform path listeners\n    const listeners = this.watchedPaths.get(path);\n    if (listeners) {\n      for (const listener of listeners) {\n        listener({ path, stats });\n      }\n    }\n  }\n\n  private async ensureFsWatcher(path: string, stats?: IFileSystemStats) {\n    if (this.fsWatchers.has(path)) {\n      return;\n    }\n\n    // accepting the optional stats saves us getting the stats ourselves\n    const pathStats = stats || (await this.statSafe(path));\n    if (!pathStats) {\n      throw new Error(`cannot watch non-existing path: ${path}`);\n    }\n\n    // open fsWatcher\n    const watchOptions = { persistent: this.options.persistent };\n    if (pathStats.isFile()) {\n      const fileWatcher = watch(path, watchOptions, (type) => this.onPathEvent(type, path));\n      fileWatcher.once('error', (e) => {\n        this.onWatchError(e, path);\n      });\n      this.fsWatchers.set(path, fileWatcher);\n    } else if (pathStats.isDirectory()) {\n      const directoryWatcher = watch(path, watchOptions, (type, fileName) => {\n        if (fileName !== null) {\n          this.onDirectoryEvent(type, path, fileName).catch((e) => {\n            this.onWatchError(e, path);\n          });\n        }\n      });\n      directoryWatcher.once('error', (e) => {\n        this.onWatchError(e, path);\n      });\n      this.fsWatchers.set(path, directoryWatcher);\n    } else {\n      throw new Error(`${path} does not point to a file or a directory`);\n    }\n  }\n\n  private onWatchError(_e: unknown, path: string) {\n    this.onPathEvent('rename', path);\n    const watcher = this.fsWatchers.get(path);\n    if (watcher) {\n      watcher.close();\n    }\n  }\n\n  private async onDirectoryEvent(eventType: string, directoryPath: string, fileName: string) {\n    // we must stats the directory, as the raw event gives us no indication\n    // whether an inner file or the directory itself was removed.\n    // Upon removal of the directory itself, the fileName parameter is just the directory name,\n    // which can also be interpreted as an inner file with that name being removed.\n    const directoryStats = await this.statSafe(directoryPath);\n    this.onPathEvent(eventType, directoryStats ? join(directoryPath, fileName) : directoryPath);\n  }\n\n  private async statSafe(nodePath: string): Promise<IFileSystemStats | null> {\n    try {\n      return await stat(nodePath);\n    } catch {\n      return null;\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": ["import_node_fs", "import_node_path", "import_utils", "fsPromises", "path", "fs", "path"]
}
