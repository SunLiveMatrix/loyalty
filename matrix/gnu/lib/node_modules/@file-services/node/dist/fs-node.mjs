// packages/node/src/node-fs.ts
import fs from "node:fs";
import path from "node:path";
import { chdir, cwd, argv } from "node:process";
import { promisify } from "node:util";
import { createFileSystem } from "@file-services/utils";

// packages/node/src/watch-service.ts
import { once } from "node:events";
import { promises as fsPromises, watch } from "node:fs";
import { join } from "node:path";
import { SetMultiMap } from "@file-services/utils";
var { stat } = fsPromises;
var NodeWatchService = class {
  /**
   * Construct a new Node file system watch service
   */
  constructor(options) {
    /** user's subsribed global listeners */
    this.globalListeners = /* @__PURE__ */ new Set();
    /** all watched paths (including files inside watched directories) */
    this.watchedPaths = new SetMultiMap();
    /** path to actual FSWatcher instance opened for it */
    this.fsWatchers = /* @__PURE__ */ new Map();
    /** path to its pending event (debounced watch event) */
    this.pendingEvents = /* @__PURE__ */ new Map();
    this.options = { persistent: true, debounceWait: 200, ...options };
  }
  async watchPath(path2, listener) {
    if (listener) {
      this.watchedPaths.add(path2, listener);
    }
    await this.ensureFsWatcher(path2);
  }
  async unwatchPath(path2, listener) {
    if (listener) {
      this.watchedPaths.delete(path2, listener);
    } else {
      this.watchedPaths.deleteKey(path2);
    }
    if (!this.watchedPaths.hasKey(path2)) {
      const fsWatcher = this.fsWatchers.get(path2);
      if (fsWatcher) {
        fsWatcher.close();
        this.fsWatchers.delete(path2);
        await once(fsWatcher, "close");
      }
    }
    const pendingEvent = this.pendingEvents.get(path2);
    if (pendingEvent) {
      clearTimeout(pendingEvent.timerId);
      this.pendingEvents.delete(path2);
    }
  }
  async unwatchAllPaths() {
    for (const watcher of this.fsWatchers.values()) {
      watcher.close();
    }
    for (const { timerId } of this.pendingEvents.values()) {
      clearTimeout(timerId);
    }
    const watcherCloseEvents = Array.from(this.fsWatchers.values(), (watcher) => once(watcher, "close"));
    this.pendingEvents.clear();
    this.fsWatchers.clear();
    this.watchedPaths.clear();
    await Promise.all(watcherCloseEvents);
  }
  addGlobalListener(listener) {
    this.globalListeners.add(listener);
  }
  removeGlobalListener(listener) {
    this.globalListeners.delete(listener);
  }
  clearGlobalListeners() {
    this.globalListeners.clear();
  }
  /**
   * Debounces watch events while retaining whether one of
   * them was a 'rename' event
   */
  onPathEvent(eventType, eventPath) {
    const pendingEvent = this.pendingEvents.get(eventPath);
    const timerId = setTimeout(() => {
      this.emitEvent(eventPath).catch((e) => this.onWatchError(e, eventPath));
    }, this.options.debounceWait);
    if (pendingEvent) {
      clearTimeout(pendingEvent.timerId);
      pendingEvent.renamed = pendingEvent.renamed || eventType === "rename";
      pendingEvent.timerId = timerId;
    } else {
      this.pendingEvents.set(eventPath, { renamed: eventType === "rename", timerId });
    }
  }
  async emitEvent(path2) {
    const pendingEvent = this.pendingEvents.get(path2);
    if (!pendingEvent) {
      return;
    }
    this.pendingEvents.delete(path2);
    const stats = await this.statSafe(path2);
    if (pendingEvent.renamed) {
      const existingWatcher = this.fsWatchers.get(path2);
      if (existingWatcher) {
        existingWatcher.close();
        this.fsWatchers.delete(path2);
        if (stats) {
          await this.ensureFsWatcher(path2, stats);
        }
      }
    }
    const watchEvent = { path: path2, stats };
    for (const listener of this.globalListeners) {
      listener(watchEvent);
    }
    const listeners = this.watchedPaths.get(path2);
    if (listeners) {
      for (const listener of listeners) {
        listener({ path: path2, stats });
      }
    }
  }
  async ensureFsWatcher(path2, stats) {
    if (this.fsWatchers.has(path2)) {
      return;
    }
    const pathStats = stats || await this.statSafe(path2);
    if (!pathStats) {
      throw new Error(`cannot watch non-existing path: ${path2}`);
    }
    const watchOptions = { persistent: this.options.persistent };
    if (pathStats.isFile()) {
      const fileWatcher = watch(path2, watchOptions, (type) => this.onPathEvent(type, path2));
      fileWatcher.once("error", (e) => {
        this.onWatchError(e, path2);
      });
      this.fsWatchers.set(path2, fileWatcher);
    } else if (pathStats.isDirectory()) {
      const directoryWatcher = watch(path2, watchOptions, (type, fileName) => {
        if (fileName !== null) {
          this.onDirectoryEvent(type, path2, fileName).catch((e) => {
            this.onWatchError(e, path2);
          });
        }
      });
      directoryWatcher.once("error", (e) => {
        this.onWatchError(e, path2);
      });
      this.fsWatchers.set(path2, directoryWatcher);
    } else {
      throw new Error(`${path2} does not point to a file or a directory`);
    }
  }
  onWatchError(_e, path2) {
    this.onPathEvent("rename", path2);
    const watcher = this.fsWatchers.get(path2);
    if (watcher) {
      watcher.close();
    }
  }
  async onDirectoryEvent(eventType, directoryPath, fileName) {
    const directoryStats = await this.statSafe(directoryPath);
    this.onPathEvent(eventType, directoryStats ? join(directoryPath, fileName) : directoryPath);
  }
  async statSafe(nodePath) {
    try {
      return await stat(nodePath);
    } catch {
      return null;
    }
  }
};

// packages/node/src/node-fs.ts
var caseSensitive = !fs.existsSync(argv[0].toUpperCase());
var fsPromisesExists = promisify(fs.exists);
function createNodeFs(options) {
  return createFileSystem(createBaseNodeFs(options));
}
function createBaseNodeFs(options) {
  return {
    ...path,
    chdir,
    cwd,
    watchService: new NodeWatchService(options && options.watchOptions),
    caseSensitive,
    ...fs,
    promises: {
      ...fs.promises,
      exists: fsPromisesExists
    }
  };
}

// packages/node/src/index.ts
var nodeFs = createNodeFs();
var src_default = nodeFs;
export {
  NodeWatchService,
  createBaseNodeFs,
  createNodeFs,
  src_default as default,
  nodeFs
};
//# sourceMappingURL=fs-node.mjs.map
