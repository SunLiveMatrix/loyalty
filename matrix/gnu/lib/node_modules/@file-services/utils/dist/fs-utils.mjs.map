{
  "version": 3,
  "sources": ["../src/create-extended-api.ts", "../src/set-multi-map.ts", "../src/sync-to-async-fs.ts"],
  "sourcesContent": ["import type {\n  IBaseFileSystemAsync,\n  IBaseFileSystemSync,\n  IFileSystemAsync,\n  IFileSystemSync,\n  IDirectoryContents,\n  IWalkOptions,\n  IFileSystemDescriptor,\n  BufferEncoding,\n  IBaseFileSystem,\n  IFileSystem,\n  IFileSystemExtendedSyncActions,\n  IFileSystemExtendedPromiseActions,\n} from '@file-services/types';\n\nconst returnsTrue = () => true;\nconst statsNoThrowOptions = { throwIfNoEntry: false } as const;\n\nexport function createFileSystem(baseFs: IBaseFileSystem): IFileSystem {\n  return {\n    ...baseFs,\n    ...createExtendedSyncActions(baseFs),\n    promises: {\n      ...baseFs.promises,\n      ...createExtendedFileSystemPromiseActions(baseFs),\n    },\n  };\n}\n\nexport function createSyncFileSystem(baseFs: IBaseFileSystemSync): IFileSystemSync {\n  return {\n    ...baseFs,\n    ...createExtendedSyncActions(baseFs),\n  };\n}\n\nexport function createExtendedSyncActions(baseFs: IBaseFileSystemSync): IFileSystemExtendedSyncActions {\n  const { statSync, mkdirSync, writeFileSync, readdirSync, readFileSync, copyFileSync, dirname, join, resolve } =\n    baseFs;\n\n  function fileExistsSync(filePath: string, statFn = statSync): boolean {\n    try {\n      return !!statFn(filePath, statsNoThrowOptions)?.isFile();\n    } catch {\n      return false;\n    }\n  }\n\n  function readJsonFileSync(filePath: string, options?: BufferEncoding | { encoding: BufferEncoding } | null): unknown {\n    return JSON.parse(readFileSync(filePath, options || 'utf8')) as unknown;\n  }\n\n  function directoryExistsSync(directoryPath: string, statFn = statSync): boolean {\n    try {\n      return !!statFn(directoryPath, statsNoThrowOptions)?.isDirectory();\n    } catch {\n      return false;\n    }\n  }\n\n  function ensureDirectorySync(directoryPath: string): void {\n    try {\n      mkdirSync(directoryPath);\n    } catch (e) {\n      const code = (e as { code?: string })?.code;\n      if (code === 'EISDIR') {\n        return;\n      } else if (code === 'EEXIST') {\n        if (directoryExistsSync(directoryPath)) {\n          return;\n        } else {\n          throw e;\n        }\n      } else if (code === 'ENOTDIR' || !code) {\n        throw e;\n      }\n\n      const parentPath = dirname(directoryPath);\n      if (parentPath === directoryPath) {\n        throw e;\n      }\n\n      ensureDirectorySync(parentPath);\n      try {\n        mkdirSync(directoryPath);\n      } catch (e) {\n        const code = (e as { code?: string })?.code;\n        const isDirectoryExistsError = code === 'EISDIR' || (code === 'EEXIST' && directoryExistsSync(directoryPath));\n        if (!isDirectoryExistsError) {\n          throw e;\n        }\n      }\n    }\n  }\n\n  function populateDirectorySync(directoryPath: string, contents: IDirectoryContents): string[] {\n    const filePaths: string[] = [];\n    ensureDirectorySync(directoryPath);\n    for (const [nodeName, nodeValue] of Object.entries(contents)) {\n      const nodePath = join(directoryPath, nodeName);\n      if (typeof nodeValue === 'string') {\n        ensureDirectorySync(dirname(nodePath));\n        writeFileSync(nodePath, nodeValue);\n        filePaths.push(nodePath);\n      } else {\n        populateDirectorySync(nodePath, nodeValue);\n      }\n    }\n    return filePaths;\n  }\n\n  function findFilesSync(rootDirectory: string, options: IWalkOptions = {}, filePaths: string[] = []): string[] {\n    const { filterFile = returnsTrue, filterDirectory = returnsTrue } = options;\n\n    for (const item of readdirSync(rootDirectory, { withFileTypes: true })) {\n      const nodePath = join(rootDirectory, item.name);\n      const nodeDesc: IFileSystemDescriptor = { name: item.name, path: nodePath };\n      if (item.isFile() && filterFile(nodeDesc)) {\n        filePaths.push(nodePath);\n      } else if (item.isDirectory() && filterDirectory(nodeDesc)) {\n        findFilesSync(nodePath, options, filePaths);\n      }\n    }\n\n    return filePaths;\n  }\n\n  function findClosestFileSync(initialDirectoryPath: string, fileName: string): string | undefined {\n    let currentPath = resolve(initialDirectoryPath);\n    let lastPath: string | undefined;\n\n    while (currentPath !== lastPath) {\n      const filePath = join(currentPath, fileName);\n      if (fileExistsSync(filePath)) {\n        return filePath;\n      }\n      lastPath = currentPath;\n      currentPath = dirname(currentPath);\n    }\n\n    return undefined;\n  }\n\n  function findFilesInAncestorsSync(initialDirectoryPath: string, fileName: string): string[] {\n    const filePaths: string[] = [];\n    let currentPath = resolve(initialDirectoryPath);\n    let lastPath: string | undefined;\n\n    while (currentPath !== lastPath) {\n      const filePath = join(currentPath, fileName);\n      if (fileExistsSync(filePath)) {\n        filePaths.push(filePath);\n      }\n      lastPath = currentPath;\n      currentPath = dirname(currentPath);\n    }\n\n    return filePaths;\n  }\n\n  function copyDirectorySync(sourcePath: string, destinationPath: string): void {\n    ensureDirectorySync(destinationPath);\n    for (const item of readdirSync(sourcePath, { withFileTypes: true })) {\n      const sourceItemPath = join(sourcePath, item.name);\n      const destinationItemPath = join(destinationPath, item.name);\n      if (item.isFile()) {\n        copyFileSync(sourceItemPath, destinationItemPath);\n      } else if (item.isDirectory()) {\n        copyDirectorySync(sourceItemPath, destinationItemPath);\n      }\n    }\n  }\n\n  return {\n    fileExistsSync,\n    directoryExistsSync,\n    // resolve path once for recursive functions\n    ensureDirectorySync: (directoryPath) => ensureDirectorySync(resolve(directoryPath)),\n    populateDirectorySync: (directoryPath, contents) => populateDirectorySync(resolve(directoryPath), contents),\n    findFilesSync: (rootDirectory, options) => findFilesSync(resolve(rootDirectory), options),\n    copyDirectorySync: (sourcePath, destinationPath) =>\n      copyDirectorySync(resolve(sourcePath), resolve(destinationPath)),\n    findClosestFileSync,\n    findFilesInAncestorsSync,\n    readJsonFileSync,\n  };\n}\n\nexport function createAsyncFileSystem(baseFs: IBaseFileSystemAsync): IFileSystemAsync {\n  return {\n    ...baseFs,\n    promises: {\n      ...baseFs.promises,\n      ...createExtendedFileSystemPromiseActions(baseFs),\n    },\n  };\n}\n\nexport function createExtendedFileSystemPromiseActions(\n  baseFs: IBaseFileSystemAsync\n): IFileSystemExtendedPromiseActions {\n  const {\n    dirname,\n    resolve,\n    join,\n    promises: { stat, mkdir, writeFile, readdir, readFile, copyFile },\n  } = baseFs;\n\n  async function fileExists(filePath: string, statFn = stat): Promise<boolean> {\n    try {\n      return (await statFn(filePath)).isFile();\n    } catch {\n      return false;\n    }\n  }\n\n  async function directoryExists(directoryPath: string, statFn = stat): Promise<boolean> {\n    try {\n      return (await statFn(directoryPath)).isDirectory();\n    } catch {\n      return false;\n    }\n  }\n\n  async function readJsonFile(\n    filePath: string,\n    options?: BufferEncoding | { encoding: BufferEncoding } | null\n  ): Promise<unknown> {\n    return JSON.parse(await readFile(filePath, options || 'utf8')) as unknown;\n  }\n\n  async function ensureDirectory(directoryPath: string): Promise<void> {\n    try {\n      await mkdir(directoryPath);\n    } catch (e) {\n      const code = (e as { code?: string })?.code;\n      if (code === 'EISDIR') {\n        return;\n      } else if (code === 'EEXIST') {\n        if (await directoryExists(directoryPath)) {\n          return;\n        } else {\n          throw e;\n        }\n      } else if (code === 'ENOTDIR' || !code) {\n        throw e;\n      }\n\n      const parentPath = dirname(directoryPath);\n      if (parentPath === directoryPath) {\n        throw e;\n      }\n\n      await ensureDirectory(parentPath);\n      try {\n        await mkdir(directoryPath);\n      } catch (e) {\n        const code = (e as { code?: string })?.code;\n        const isDirectoryExistsError =\n          code === 'EISDIR' || (code === 'EEXIST' && (await directoryExists(directoryPath)));\n        if (!isDirectoryExistsError) {\n          throw e;\n        }\n      }\n    }\n  }\n\n  async function populateDirectory(directoryPath: string, contents: IDirectoryContents): Promise<string[]> {\n    const filePaths: string[] = [];\n    await ensureDirectory(directoryPath);\n    for (const [nodeName, nodeValue] of Object.entries(contents)) {\n      const nodePath = join(directoryPath, nodeName);\n      if (typeof nodeValue === 'string') {\n        await ensureDirectory(dirname(nodePath));\n        await writeFile(nodePath, nodeValue);\n        filePaths.push(nodePath);\n      } else {\n        await populateDirectory(nodePath, nodeValue);\n      }\n    }\n    return filePaths;\n  }\n\n  async function findFiles(\n    rootDirectory: string,\n    options: IWalkOptions = {},\n    filePaths: string[] = []\n  ): Promise<string[]> {\n    const { filterFile = returnsTrue, filterDirectory = returnsTrue } = options;\n\n    for (const item of await readdir(rootDirectory, { withFileTypes: true })) {\n      const nodePath = join(rootDirectory, item.name);\n      const nodeDesc: IFileSystemDescriptor = { name: item.name, path: nodePath };\n      if (item.isFile() && filterFile(nodeDesc)) {\n        filePaths.push(nodePath);\n      } else if (item.isDirectory() && filterDirectory(nodeDesc)) {\n        await findFiles(nodePath, options, filePaths);\n      }\n    }\n\n    return filePaths;\n  }\n\n  async function findClosestFile(initialDirectoryPath: string, fileName: string): Promise<string | undefined> {\n    let currentPath = resolve(initialDirectoryPath);\n    let lastPath: string | undefined;\n\n    while (currentPath !== lastPath) {\n      const filePath = join(currentPath, fileName);\n      if (await fileExists(filePath)) {\n        return filePath;\n      }\n      lastPath = currentPath;\n      currentPath = dirname(currentPath);\n    }\n\n    return undefined;\n  }\n\n  async function findFilesInAncestors(initialDirectoryPath: string, fileName: string): Promise<string[]> {\n    const filePaths: string[] = [];\n    let currentPath = resolve(initialDirectoryPath);\n    let lastPath: string | undefined;\n\n    while (currentPath !== lastPath) {\n      const filePath = join(currentPath, fileName);\n      if (await fileExists(filePath)) {\n        filePaths.push(filePath);\n      }\n      lastPath = currentPath;\n      currentPath = dirname(currentPath);\n    }\n\n    return filePaths;\n  }\n\n  async function copyDirectory(sourcePath: string, destinationPath: string): Promise<void> {\n    await ensureDirectory(destinationPath);\n    for (const item of await readdir(sourcePath, { withFileTypes: true })) {\n      const sourceItemPath = join(sourcePath, item.name);\n      const destinationItemPath = join(destinationPath, item.name);\n      if (item.isFile()) {\n        await copyFile(sourceItemPath, destinationItemPath);\n      } else if (item.isDirectory()) {\n        await copyDirectory(sourceItemPath, destinationItemPath);\n      }\n    }\n  }\n\n  return {\n    fileExists,\n    directoryExists,\n    ensureDirectory: (directoryPath) => ensureDirectory(resolve(directoryPath)),\n    populateDirectory: (directoryPath, contents) => populateDirectory(resolve(directoryPath), contents),\n    findFiles: (rootDirectory, options) => findFiles(resolve(rootDirectory), options),\n    copyDirectory: (sourcePath, destinationPath) => copyDirectory(resolve(sourcePath), resolve(destinationPath)),\n    findClosestFile,\n    findFilesInAncestors,\n    readJsonFile,\n  };\n}\n", "export class SetMultiMap<K, V> implements Iterable<[K, V]> {\n  private map = new Map<K, Set<V>>();\n\n  public get size(): number {\n    return Array.from(this.map.values())\n      .map(({ size }) => size)\n      .reduce((sum, size) => sum + size, 0);\n  }\n\n  public get(key: K): ReadonlySet<V> | undefined {\n    return this.map.get(key);\n  }\n\n  public add(key: K, value: V): this {\n    const valueSet = this.map.get(key);\n    if (valueSet) {\n      valueSet.add(value);\n    } else {\n      this.map.set(key, new Set([value]));\n    }\n    return this;\n  }\n\n  public clear(): void {\n    this.map.clear();\n  }\n\n  public delete(key: K, value: V): boolean {\n    const valueSet = this.map.get(key);\n    if (valueSet) {\n      const wasInSet = valueSet.delete(value);\n      if (valueSet.size === 0) {\n        this.map.delete(key);\n      }\n      return wasInSet;\n    }\n    return false;\n  }\n\n  public deleteKey(key: K): boolean {\n    return this.map.delete(key);\n  }\n\n  public has(key: K, value: V): boolean {\n    const valueSet = this.map.get(key);\n    return valueSet ? valueSet.has(value) : false;\n  }\n\n  public hasKey(key: K): boolean {\n    const existingSet = this.map.get(key);\n    return !!existingSet && existingSet.size > 0;\n  }\n\n  public [Symbol.iterator](): IterableIterator<[K, V]> {\n    return this.entries();\n  }\n\n  public *entries(): IterableIterator<[K, V]> {\n    const { map } = this;\n    for (const [key, valueSet] of map.entries()) {\n      for (const value of valueSet) {\n        yield [key, value];\n      }\n    }\n  }\n\n  public *values(): IterableIterator<V> {\n    const { map } = this;\n    for (const valueSet of map.values()) {\n      for (const value of valueSet) {\n        yield value;\n      }\n    }\n  }\n\n  public keys(): IterableIterator<K> {\n    return this.map.keys();\n  }\n}\n", "import type {\n  IBaseFileSystemSync,\n  IBaseFileSystemAsync,\n  IBaseFileSystemPromiseActions,\n  CallbackFnVoid,\n} from '@file-services/types';\n\nexport function syncToAsyncFs(syncFs: IBaseFileSystemSync): IBaseFileSystemAsync {\n  return {\n    ...syncFs,\n    watchService: syncFs.watchService,\n    caseSensitive: syncFs.caseSensitive,\n\n    promises: {\n      readFile: async function readFile(...args: [string]) {\n        return syncFs.readFileSync(...args);\n      } as IBaseFileSystemPromiseActions['readFile'],\n      async writeFile(...args) {\n        return syncFs.writeFileSync(...args);\n      },\n      async unlink(filePath) {\n        return syncFs.unlinkSync(filePath);\n      },\n      readdir: async function readdir(...args: [string]) {\n        return syncFs.readdirSync(...args);\n      } as IBaseFileSystemPromiseActions['readdir'],\n      async mkdir(directoryPath, ...args) {\n        return syncFs.mkdirSync(directoryPath, ...args);\n      },\n      async rmdir(directoryPath) {\n        return syncFs.rmdirSync(directoryPath);\n      },\n      async exists(nodePath) {\n        return syncFs.existsSync(nodePath);\n      },\n      async stat(nodePath) {\n        return syncFs.statSync(nodePath);\n      },\n      async lstat(nodePath) {\n        return syncFs.lstatSync(nodePath);\n      },\n      async realpath(nodePath) {\n        return syncFs.realpathSync(nodePath);\n      },\n      async rename(srcPath, destPath) {\n        return syncFs.renameSync(srcPath, destPath);\n      },\n      async copyFile(...args) {\n        return syncFs.copyFileSync(...args);\n      },\n      async readlink(path) {\n        return syncFs.readlinkSync(path);\n      },\n      async symlink(...args) {\n        return syncFs.symlinkSync(...args);\n      },\n      async rm(...args) {\n        return syncFs.rmSync(...args);\n      },\n      async chmod(...args) {\n        return syncFs.chmodSync(...args);\n      },\n    },\n    exists(nodePath, callback) {\n      callback(syncFs.existsSync(nodePath));\n    },\n    readFile: callbackify(syncFs.readFileSync) as IBaseFileSystemAsync['readFile'],\n    writeFile: callbackify(syncFs.writeFileSync) as IBaseFileSystemAsync['writeFile'],\n    copyFile: callbackify(syncFs.copyFileSync) as IBaseFileSystemAsync['copyFile'],\n    unlink: callbackify(syncFs.unlinkSync),\n    readdir: callbackify(syncFs.readdirSync) as IBaseFileSystemAsync['readdir'],\n    mkdir: callbackify(syncFs.mkdirSync) as unknown as IBaseFileSystemAsync['mkdir'],\n    rmdir: callbackify(syncFs.rmdirSync),\n    stat: callbackify(syncFs.statSync) as unknown as IBaseFileSystemAsync['stat'],\n    lstat: callbackify(syncFs.lstatSync) as unknown as IBaseFileSystemAsync['lstat'],\n    realpath: callbackify(syncFs.realpathSync),\n    rename: callbackify(syncFs.renameSync),\n    readlink: callbackify(syncFs.readlinkSync),\n  };\n}\n\nfunction callbackify<T extends unknown[], R>(fn: (...args: [...T]) => R) {\n  return (...args: [...T, (error: Error | null, value: R) => void]): void => {\n    const callback = args.pop() as (error: Error | null, value: R) => void;\n    if (typeof callback !== 'function') {\n      throw new Error('callback is not a function');\n    }\n    try {\n      const result = fn(...(args as unknown as [...T]));\n      callback(null, result);\n    } catch (e) {\n      (callback as CallbackFnVoid)(e as Error | undefined | null);\n    }\n  };\n}\n"],
  "mappings": "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",
  "names": ["e", "code"]
}
