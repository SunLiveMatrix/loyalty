"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.reExportsAllSymbols = exports.IndexGenerator = void 0;
const node_1 = require("@file-services/node");
const index_internal_1 = require("@stylable/core/dist/index-internal");
const lodash_camelcase_1 = __importDefault(require("lodash.camelcase"));
const lodash_upperfirst_1 = __importDefault(require("lodash.upperfirst"));
const build_tools_1 = require("./build-tools");
const logger_1 = require("./logger");
class IndexGenerator {
    constructor({ log, stylable, indexFileTargetPath, fs }) {
        this.indexFileOutput = new Map();
        this.collisionDetector = new NameCollisionDetector();
        this.stylable = stylable;
        this.indexFileTargetPath = indexFileTargetPath;
        this.log = log ?? (0, logger_1.createDefaultLogger)();
        this.fs = fs ?? node_1.nodeFs;
    }
    generateReExports(filePath) {
        return {
            root: this.filename2varname(filePath),
            classes: {},
            keyframes: {},
            stVars: {},
            vars: {},
        };
    }
    generateFileIndexEntry(filePath) {
        const reExports = this.generateReExports(filePath);
        if (reExports) {
            this.checkForCollisions(reExports, filePath);
            this.log('[Generator Index]', `Add file: ${filePath}`);
            this.indexFileOutput.set((0, build_tools_1.normalizeRelative)(this.fs.relative(this.fs.dirname(this.indexFileTargetPath), filePath)), reExports);
        }
    }
    removeEntryFromIndex(filePath) {
        this.indexFileOutput.delete((0, build_tools_1.normalizeRelative)(this.fs.relative(this.fs.dirname(this.indexFileTargetPath), filePath)));
    }
    async generateIndexFile(fs) {
        const indexFileContent = this.generateIndexSource();
        (0, build_tools_1.ensureDirectory)(fs.dirname(this.indexFileTargetPath), fs);
        await (0, build_tools_1.tryRun)(() => fs.promises.writeFile(this.indexFileTargetPath, '\n' + indexFileContent + '\n'), 'Write Index File Error');
        this.log('[Generator Index]', 'creating index file: ' + this.indexFileTargetPath);
    }
    filename2varname(filePath) {
        const varname = this.fs
            .basename(this.fs.basename(filePath, '.css'), '.st') // remove prefixes and .st.css ext
            .replace(/^\d+/, ''); // remove leading numbers
        return (0, lodash_upperfirst_1.default)((0, lodash_camelcase_1.default)(varname));
    }
    generateIndexSource() {
        return [...this.indexFileOutput.entries()]
            .map(([from, reExports]) => createImportForComponent(from, reExports))
            .join('\n');
    }
    checkForCollisions(reExports, filePath) {
        this.collisionDetector.detect(reExports.root, filePath);
        for (const asName of Object.values(reExports.classes)) {
            this.collisionDetector.detect(asName, filePath);
        }
        for (const asName of Object.values(reExports.vars)) {
            this.collisionDetector.detect(asName, filePath);
        }
        for (const asName of Object.values(reExports.stVars)) {
            this.collisionDetector.detect(asName, filePath);
        }
        for (const asName of Object.values(reExports.keyframes)) {
            this.collisionDetector.detect(`keyframes(${asName})`, filePath);
        }
        if (this.collisionDetector.collisions.size) {
            let errorMessage = 'Name Collision Error:';
            for (const [name, origin] of this.collisionDetector.collisions) {
                errorMessage += `\nexport symbol ${name} from ${filePath} is already used by ${origin}`;
            }
            throw new Error(errorMessage);
        }
    }
}
exports.IndexGenerator = IndexGenerator;
function reExportsAllSymbols(filePath, generator) {
    const meta = generator.stylable.analyze(filePath);
    const rootExport = generator.filename2varname(filePath);
    const classes = Object.keys(meta.getAllClasses())
        .filter((name) => name !== meta.root)
        .reduce((acc, className) => {
        acc[className] = `${rootExport}__${className}`;
        return acc;
    }, {});
    const stVars = Object.values(meta.getAllStVars()).reduce((acc, { name }) => {
        acc[name] = `${rootExport}__${name}`;
        return acc;
    }, {});
    const vars = Object.keys(index_internal_1.STSymbol.getAllByType(meta, `cssVar`)).reduce((acc, varName) => {
        acc[varName] = `--${rootExport}__${varName.slice(2)}`;
        return acc;
    }, {});
    const keyframes = Object.keys(index_internal_1.STSymbol.getAllByType(meta, `keyframes`)).reduce((acc, keyframe) => {
        acc[keyframe] = `${rootExport}__${keyframe}`;
        return acc;
    }, {});
    return {
        root: rootExport,
        classes,
        keyframes,
        stVars,
        vars,
    };
}
exports.reExportsAllSymbols = reExportsAllSymbols;
class NameCollisionDetector {
    constructor() {
        this.nameMapping = new Map();
        this.collisions = new Map();
    }
    detect(name, origin) {
        if (this.nameMapping.has(name) && origin !== this.nameMapping.get(name)) {
            this.collisions.set(name, this.nameMapping.get(name));
        }
        else {
            this.nameMapping.set(name, origin);
        }
    }
}
function createImportForComponent(from, reExports) {
    const namedPart = [
        ...Object.entries(reExports.classes).map(symbolMapper),
        ...Object.entries(reExports.stVars).map(symbolMapper),
        ...Object.entries(reExports.vars).map(symbolMapper),
        ...Object.entries(reExports.keyframes).map(keyframesSymbolMapper),
    ].join(', ');
    const usagePart = Object.values(reExports.classes)
        .map((exportName) => `.root .${exportName}{}`)
        .join(' ');
    return `:import {-st-from: ${JSON.stringify(from)};-st-default:${reExports.root};${namedPart ? `-st-named: ${namedPart};` : ''}}\n.root ${reExports.root}{}${usagePart ? `\n${usagePart}` : ''}`;
}
function symbolMapper([name, as]) {
    return name === as ? as : `${name} as ${as}`;
}
function keyframesSymbolMapper([name, as]) {
    return name === as ? `keyframes(${as})` : `keyframes(${name} as ${as})`;
}
//# sourceMappingURL=base-generator.js.map