"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAllDiagnostics = exports.removeBuildProducts = exports.buildDTS = exports.buildSingleFile = void 0;
const core_1 = require("@stylable/core");
const index_internal_1 = require("@stylable/core/dist/index-internal");
const module_utils_1 = require("@stylable/module-utils");
const optimizer_1 = require("@stylable/optimizer");
const build_tools_1 = require("@stylable/build-tools");
const build_tools_2 = require("./build-tools");
const name_template_1 = require("./name-template");
const diagnostics_manager_1 = require("./diagnostics-manager");
const messages_1 = require("./messages");
const file_to_data_uri_1 = require("./file-to-data-uri");
function buildSingleFile({ fullOutDir, filePath, fullSrcDir, identifier = fullSrcDir, log, fs, moduleFormats, outputCSS = false, outputCSSNameTemplate = '[filename].css', outputSources = false, generated = new Set(), mode = '[Build]', 
// build specific
stylable, includeCSSInJS = false, projectAssets, useNamespaceReference = true, injectCSSRequest = false, optimize = false, minify = false, dts = false, dtsSourceMap, diagnosticsMode = 'loose', resolveRuntimeRequest, diagnosticsManager = new diagnostics_manager_1.DiagnosticsManager({ log }), }) {
    const { basename, dirname, join, relative, resolve, isAbsolute } = fs;
    const targetFilePath = join(fullOutDir, relative(fullSrcDir, filePath));
    const outPath = targetFilePath + '.js';
    const fileDirectory = dirname(filePath);
    const outDirPath = dirname(outPath);
    const cssAssetFilename = (0, name_template_1.nameTemplate)(outputCSSNameTemplate, {
        filename: basename(targetFilePath, '.st.css'),
    });
    const cssAssetOutPath = join(dirname(targetFilePath), cssAssetFilename);
    const outputLogs = [];
    log(mode, filePath);
    let content = (0, build_tools_2.tryRun)(() => fs.readFileSync(filePath).toString(), `Read File Error: ${filePath}`);
    const res = (0, build_tools_2.tryRun)(() => stylable.transform(stylable.analyze(filePath)), messages_1.errorMessages.STYLABLE_PROCESS(filePath));
    const optimizer = new optimizer_1.StylableOptimizer();
    if (optimize) {
        optimizer.optimize({
            removeComments: true,
            removeEmptyNodes: true,
            classNameOptimizations: false,
            removeUnusedComponents: false,
        }, res, {});
    }
    const diagnostics = getAllDiagnostics(res);
    if (diagnostics.length) {
        diagnosticsManager.set(identifier, filePath, {
            diagnosticsMode,
            diagnostics,
        });
    }
    if (outputSources || outputCSS || dts || moduleFormats.length) {
        (0, build_tools_2.tryRun)(() => (0, build_tools_2.ensureDirectory)(outDirPath, fs), `Ensure directory: ${outDirPath}`);
    }
    // st.css
    if (outputSources) {
        if (targetFilePath === filePath) {
            throw new Error(`Attempt to override source file ${targetFilePath}`);
        }
        if (useNamespaceReference && !content.includes('st-namespace-reference')) {
            const relativePathToSource = relative(dirname(targetFilePath), filePath).replace(/\\/gm, '/');
            const srcNamespaceAnnotation = `\n/* st-namespace-reference="${relativePathToSource}" */`;
            content += srcNamespaceAnnotation;
        }
        generated.add(targetFilePath);
        outputLogs.push(`.st.css source`);
        (0, build_tools_2.tryRun)(() => fs.writeFileSync(targetFilePath, content), `Write File Error: ${targetFilePath}`);
    }
    // st.css.js
    const ast = includeCSSInJS
        ? (0, build_tools_2.tryRun)(() => inlineAssetsForJsModule(res, stylable, fs), `Inline assets failed for: ${filePath}`)
        : res.meta.targetAst;
    moduleFormats.forEach(([format, ext]) => {
        outputLogs.push(`${format} module`);
        const moduleCssImports = collectImportsWithSideEffects(res, stylable, ext);
        const cssDepth = res.meta.transformCssDepth?.cssDepth ?? 0;
        if (injectCSSRequest) {
            moduleCssImports.push({ from: './' + cssAssetFilename });
        }
        const code = (0, core_1.generateStylableJSModuleSource)({
            jsExports: res.exports,
            moduleType: format,
            namespace: res.meta.namespace,
            varType: 'var',
            imports: moduleCssImports,
            runtimeRequest: resolveRuntimeRequest(targetFilePath, format),
        }, includeCSSInJS
            ? {
                css: ast.toString(),
                depth: cssDepth,
                id: res.meta.namespace,
                runtimeId: format,
            }
            : undefined);
        const outFilePath = targetFilePath + ext;
        generated.add(outFilePath);
        (0, build_tools_2.tryRun)(() => fs.writeFileSync(outFilePath, code), `Write File Error: ${outFilePath}`);
    });
    // .css
    if (outputCSS) {
        let cssCode = res.meta.targetAst.toString();
        if (minify) {
            cssCode = optimizer.minifyCSS(cssCode);
        }
        generated.add(cssAssetOutPath);
        outputLogs.push('transpiled css');
        (0, build_tools_2.tryRun)(() => fs.writeFileSync(cssAssetOutPath, cssCode), `Write File Error: ${cssAssetOutPath}`);
    }
    // .d.ts
    if (dts) {
        buildDTS({
            res,
            targetFilePath,
            generated,
            outputLogs,
            dtsSourceMap,
            sourceFilePath: outputSources ? undefined : filePath,
            writeFileSync: fs.writeFileSync,
            relative,
            dirname,
            isAbsolute,
        });
    }
    log(mode, `output: [${outputLogs.join(', ')}]`);
    // copy assets
    for (const url of res.meta.urls) {
        if ((0, index_internal_1.isAsset)(url)) {
            projectAssets.add(resolve(fileDirectory, url));
        }
    }
    // add native css imports as assets
    for (const { request } of res.meta.getImportStatements()) {
        try {
            const resolvedRequest = stylable.resolver.resolvePath(fileDirectory, request);
            if ((0, index_internal_1.isRelativeNativeCss)(resolvedRequest)) {
                projectAssets.add(resolvedRequest);
                buildSingleFile({
                    fullOutDir,
                    filePath: resolvedRequest,
                    fullSrcDir,
                    log,
                    fs,
                    moduleFormats,
                    outputCSS: false,
                    outputSources: false,
                    generated,
                    mode,
                    stylable,
                    includeCSSInJS,
                    projectAssets,
                    useNamespaceReference,
                    injectCSSRequest,
                    optimize,
                    minify,
                    dts: false,
                    dtsSourceMap: false,
                    diagnosticsMode,
                    diagnosticsManager,
                    resolveRuntimeRequest,
                });
            }
        }
        catch (_e) {
            // resolve diagnostics reported by core
        }
    }
    return {
        targetFilePath,
    };
}
exports.buildSingleFile = buildSingleFile;
function buildDTS({ res, targetFilePath, generated, outputLogs, dtsSourceMap, sourceFilePath, writeFileSync, relative, dirname, isAbsolute, }) {
    const dtsContent = (0, module_utils_1.generateDTSContent)(res);
    const dtsPath = targetFilePath + '.d.ts';
    generated.add(dtsPath);
    outputLogs.push('output .d.ts');
    (0, build_tools_2.tryRun)(() => writeFileSync(dtsPath, dtsContent), `Write File Error: ${dtsPath}`);
    // .d.ts.map
    // if not explicitly defined, assumed true with "--dts" parent scope
    if (dtsSourceMap !== false) {
        const relativeTargetFilePath = relative(dirname(targetFilePath), sourceFilePath || targetFilePath);
        const dtsMappingContent = (0, module_utils_1.generateDTSSourceMap)(dtsContent, res.meta, 
        // `relativeTargetFilePath` could be an absolute path in windows (e.g. unc path)
        isAbsolute(relativeTargetFilePath)
            ? relativeTargetFilePath
            : relativeTargetFilePath.replace(/\\/g, '/'));
        const dtsMapPath = targetFilePath + '.d.ts.map';
        generated.add(dtsMapPath);
        outputLogs.push('output .d.ts.mp');
        (0, build_tools_2.tryRun)(() => writeFileSync(dtsMapPath, dtsMappingContent), `Write File Error: ${dtsMapPath}`);
    }
}
exports.buildDTS = buildDTS;
function collectImportsWithSideEffects(res, stylable, ext) {
    const moduleCssImports = [];
    for (const imported of res.meta.getImportStatements()) {
        let resolved = imported.request;
        try {
            resolved = stylable.resolver.resolvePath(imported.context, imported.request);
        }
        catch {
            // use the fallback
        }
        if (resolved.endsWith('.st.css')) {
            if ((0, build_tools_1.hasImportedSideEffects)(stylable, res.meta, imported)) {
                // TODO: solve issue where request must be resolved before we add the extension
                moduleCssImports.push({ from: imported.request + ext });
            }
        }
        if (resolved.endsWith('.css')) {
            moduleCssImports.push({ from: imported.request + ext });
        }
    }
    return moduleCssImports;
}
function inlineAssetsForJsModule(res, stylable, fs) {
    const ast = res.meta.targetAst.clone();
    (0, build_tools_1.processUrlDependencies)({
        meta: { targetAst: ast, source: res.meta.source },
        rootContext: stylable.projectRoot,
        getReplacement: ({ absoluteRequest, url }) => {
            if ((0, index_internal_1.isAsset)(url)) {
                let content = fs.readFileSync(absoluteRequest);
                if (typeof content === 'string') {
                    content = Buffer.from(content);
                }
                return (0, file_to_data_uri_1.fileToDataUri)(absoluteRequest, content);
            }
            return url;
        },
        host: fs,
    });
    return ast;
}
function removeBuildProducts({ fullOutDir, filePath, fullSrcDir, log, fs, moduleFormats, outputCSS = false, outputCSSNameTemplate = '[filename].css', outputSources = false, generated = new Set(), mode = '[Build]', dts = false, dtsSourceMap, }) {
    const { basename, dirname, join, relative } = fs;
    const targetFilePath = join(fullOutDir, relative(fullSrcDir, filePath));
    const cssAssetFilename = (0, name_template_1.nameTemplate)(outputCSSNameTemplate, {
        filename: basename(targetFilePath, '.st.css'),
    });
    const cssAssetOutPath = join(dirname(targetFilePath), cssAssetFilename);
    const outputLogs = [];
    log(mode, filePath);
    // st.css
    if (outputSources) {
        if (targetFilePath === filePath) {
            throw new Error(`Attempt to remove source file ${targetFilePath}`);
        }
        generated.delete(targetFilePath);
        outputLogs.push(`.st.css source`);
        (0, build_tools_2.tryRun)(() => fs.unlinkSync(targetFilePath), `Unlink File Error: ${targetFilePath}`);
    }
    // st.css.js
    moduleFormats.forEach(([format, ext]) => {
        outputLogs.push(`${format} module`);
        const outFilePath = targetFilePath + ext;
        generated.delete(outFilePath);
        (0, build_tools_2.tryRun)(() => fs.unlinkSync(outFilePath), `Unlink File Error: ${outFilePath}`);
    });
    // .css
    if (outputCSS) {
        generated.delete(cssAssetOutPath);
        outputLogs.push('transpiled css');
        (0, build_tools_2.tryRun)(() => fs.unlinkSync(cssAssetOutPath), `Unlink File Error: ${cssAssetOutPath}`);
    }
    // .d.ts
    if (dts) {
        const dtsPath = `${targetFilePath}.d.ts`;
        generated.delete(dtsPath);
        outputLogs.push('generated .d.ts');
        (0, build_tools_2.tryRun)(() => fs.unlinkSync(dtsPath), `Unlink File Error: ${dtsPath}`);
    }
    // .d.ts.map
    if (dtsSourceMap) {
        const dtsMapPath = `${targetFilePath}.d.ts.map`;
        generated.delete(dtsMapPath);
        outputLogs.push('generated .d.ts.map');
        (0, build_tools_2.tryRun)(() => fs.unlinkSync(dtsMapPath), `Unlink File Error: ${dtsMapPath}`);
    }
    log(mode, `removed: [${outputLogs.join(', ')}]`);
    return {
        targetFilePath,
    };
}
exports.removeBuildProducts = removeBuildProducts;
function getAllDiagnostics(res) {
    const diagnostics = res.meta.transformDiagnostics
        ? res.meta.diagnostics.reports.concat(res.meta.transformDiagnostics.reports)
        : res.meta.diagnostics.reports;
    return diagnostics.map(({ message, node, word, severity, code }) => {
        const err = node.error(message, { word });
        const diagnostic = {
            severity,
            node,
            code,
            message: `${message}\n${err.showSourceCode(true)}`,
            ...(node.source?.start && {}),
        };
        return diagnostic;
    });
}
exports.getAllDiagnostics = getAllDiagnostics;
//# sourceMappingURL=build-single-file.js.map