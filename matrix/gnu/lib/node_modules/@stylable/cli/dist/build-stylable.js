"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildStylable = void 0;
const node_1 = require("@file-services/node");
const core_1 = require("@stylable/core");
const index_internal_1 = require("@stylable/core/dist/index-internal");
const build_1 = require("./build");
const projects_config_1 = require("./config/projects-config");
const resolve_options_1 = require("./config/resolve-options");
const diagnostics_manager_1 = require("./diagnostics-manager");
const logger_1 = require("./logger");
const watch_handler_1 = require("./watch-handler");
async function buildStylable(rootDir, { defaultOptions = (0, resolve_options_1.createDefaultOptions)(), overrideBuildOptions = {}, fs: fileSystem = node_1.nodeFs, log = (0, logger_1.createDefaultLogger)(), watch = false, resolverCache = new Map(), fileProcessorCache = {}, diagnosticsManager = new diagnostics_manager_1.DiagnosticsManager({
    log,
    hooks: {
        postReport(_diagnostics, hasFatalDiagnostic) {
            if (hasFatalDiagnostic && !watch) {
                process.exitCode = 1;
            }
        },
    },
}), outputFiles = new Map(), requireModule = require, resolveNamespace = requireModule(resolve_options_1.NAMESPACE_RESOLVER_MODULE_REQUEST).resolveNamespace, configFilePath, watchOptions = {}, } = {}) {
    const { config } = (0, projects_config_1.resolveConfig)(rootDir, configFilePath, node_1.nodeFs) || {};
    (0, index_internal_1.validateDefaultConfig)(config?.defaultConfig);
    const projects = await (0, projects_config_1.projectsConfig)(rootDir, overrideBuildOptions, defaultOptions, config);
    const watchHandler = new watch_handler_1.WatchHandler(fileSystem, {
        log,
        resolverCache,
        outputFiles,
        rootDir,
        diagnosticsManager,
    });
    for (const { projectRoot, options } of projects) {
        for (let i = 0; i < options.length; i++) {
            const buildOptions = options[i];
            const identifier = (0, resolve_options_1.createBuildIdentifier)(rootDir, projectRoot, i, options.length > 1, projects.length > 1);
            log('[Project]', projectRoot, buildOptions);
            if (!(0, resolve_options_1.hasStylableCSSOutput)(buildOptions)) {
                log(`No target output declared for "${identifier}", please provide one or more of the following target options: "cjs", "esm", "css", "stcss" or "indexFile"`, logger_1.levels.info);
            }
            const stylable = new core_1.Stylable({
                fileSystem,
                requireModule,
                projectRoot,
                resolveNamespace,
                resolverCache,
                fileProcessorCache,
                ...config?.defaultConfig,
            });
            const { service, generatedFiles } = await (0, build_1.build)(buildOptions, {
                watch,
                stylable,
                log,
                fs: fileSystem,
                rootDir,
                projectRoot,
                outputFiles,
                identifier,
                diagnosticsManager,
            });
            watchHandler.register({ service, identifier, stylable, generatedFiles });
        }
    }
    diagnosticsManager.report();
    if (watch && !watchOptions.lazy) {
        watchHandler.start();
    }
    return { watchHandler, outputFiles, projects, diagnosticsManager };
}
exports.buildStylable = buildStylable;
//# sourceMappingURL=build-stylable.js.map