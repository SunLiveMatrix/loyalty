"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createWatchEvent = exports.DirectoryProcessService = void 0;
const node_1 = __importDefault(require("@file-services/node"));
const walk_fs_1 = require("./walk-fs");
class DirectoryProcessService {
    constructor(fs, options = {}) {
        this.fs = fs;
        this.options = options;
        this.invalidationMap = new Map();
        this.watchedDirectoryFiles = new Map();
        this.watchHandler = (event) => {
            const files = new Map();
            files.set(event.path, event);
            for (const file of this.getAffectedFiles(event.path)) {
                files.set(file, createWatchEvent(file, this.fs));
            }
            this.handleWatchChange(files, event).catch((error) => this.options.onError?.(error));
        };
        this.filterWatchItems = (event) => {
            const { fileFilter, directoryFilter } = this.options;
            if (event.type === 'file' && (fileFilter?.(event.path) ?? true)) {
                return true;
            }
            else if (event.type === 'directory' && (directoryFilter?.(event.path) ?? true)) {
                return true;
            }
            return false;
        };
        if (this.options.watchMode && !this.options.watchOptions?.skipInitialWatch) {
            this.startWatch();
        }
    }
    startWatch() {
        this.fs.watchService.addGlobalListener(this.watchHandler);
    }
    async dispose() {
        for (const path of this.watchedDirectoryFiles.keys()) {
            await this.fs.watchService.unwatchPath(path);
        }
        this.invalidationMap.clear();
        this.watchedDirectoryFiles.clear();
    }
    async init(directoryPath) {
        await this.watchPath(directoryPath);
        const items = (0, walk_fs_1.directoryDeepChildren)(this.fs, directoryPath, this.filterWatchItems);
        const affectedFiles = new Set();
        for await (const item of items) {
            if (item.type === 'directory') {
                await this.watchPath(item.path);
            }
            else if (item.type === 'file') {
                affectedFiles.add(item.path);
                this.addFileToWatchedDirectory(item.path);
                this.registerInvalidateOnChange(item.path);
            }
        }
        if (affectedFiles.size) {
            try {
                await this.options.processFiles?.(this, affectedFiles, new Set());
            }
            catch (error) {
                this.options.onError?.(error);
            }
        }
        return affectedFiles;
    }
    addFileToWatchedDirectory(filePath) {
        const dirName = this.fs.dirname(filePath);
        let fileSet = this.watchedDirectoryFiles.get(dirName);
        if (!fileSet) {
            fileSet = new Set();
            this.watchedDirectoryFiles.set(dirName, fileSet);
        }
        fileSet.add(filePath);
    }
    removeFileFromWatchedDirectory(filePath) {
        const dirName = this.fs.dirname(filePath);
        const fileSet = this.watchedDirectoryFiles.get(dirName);
        if (fileSet) {
            fileSet.delete(filePath);
            if (fileSet.size === 0) {
                this.watchedDirectoryFiles.delete(dirName);
            }
        }
    }
    registerInvalidateOnChange(watchedFilePath, filePathToInvalidate) {
        let fileSet = this.invalidationMap.get(watchedFilePath);
        if (!fileSet) {
            fileSet = new Set();
            this.invalidationMap.set(watchedFilePath, fileSet);
        }
        if (filePathToInvalidate) {
            fileSet.add(filePathToInvalidate);
        }
    }
    watchPath(directoryPath) {
        if (!this.options.watchMode) {
            return;
        }
        this.watchedDirectoryFiles.set(directoryPath, new Set());
        return this.fs.watchService.watchPath(directoryPath);
    }
    async handleWatchChange(files, originalEvent) {
        const affectedFiles = new Set();
        const deletedFiles = new Set();
        for (const event of files.values()) {
            if (event.stats?.isDirectory()) {
                if (this.options.directoryFilter?.(event.path) ?? true) {
                    for (const filePath of await this.init(event.path)) {
                        affectedFiles.add(filePath);
                    }
                }
                continue;
            }
            if (this.options.fileFilter?.(event.path) ?? true) {
                if (event.stats) {
                    this.registerInvalidateOnChange(event.path);
                    this.addFileToWatchedDirectory(event.path);
                    affectedFiles.add(event.path);
                }
                else {
                    this.invalidationMap.delete(event.path);
                    this.removeFileFromWatchedDirectory(event.path);
                    deletedFiles.add(event.path);
                }
                if (this.options.autoResetInvalidations) {
                    for (const filePath of affectedFiles) {
                        const invalidationSet = this.invalidationMap.get(filePath);
                        invalidationSet?.clear();
                    }
                }
            }
            else if (!event.stats) {
                // handle deleted directory
                const fileSet = new Set();
                for (const [dirPath, files] of this.watchedDirectoryFiles) {
                    if (dirPath.startsWith(event.path)) {
                        for (const filePath of files) {
                            fileSet.add(filePath);
                        }
                    }
                }
                if (fileSet.size) {
                    for (const filePath of fileSet) {
                        this.getAffectedFiles(filePath, deletedFiles);
                    }
                    for (const filePath of deletedFiles) {
                        this.invalidationMap.delete(filePath);
                        this.removeFileFromWatchedDirectory(filePath);
                    }
                }
            }
        }
        if (this.options.processFiles && (affectedFiles.size || deletedFiles.size)) {
            const { generatedFiles } = await this.options.processFiles(this, affectedFiles, deletedFiles, originalEvent);
            return {
                hasChanges: true,
                generatedFiles,
            };
        }
        else {
            return {
                hasChanges: false,
                generatedFiles: new Set(),
            };
        }
    }
    getAffectedFiles(filePath, visited = new Set()) {
        if (visited.has(filePath)) {
            return visited;
        }
        visited.add(filePath);
        const fileSet = this.invalidationMap.get(filePath);
        if (!fileSet) {
            return visited;
        }
        for (const file of fileSet) {
            this.getAffectedFiles(file, visited);
        }
        return visited;
    }
}
exports.DirectoryProcessService = DirectoryProcessService;
function createWatchEvent(filePath, fs = node_1.default) {
    return {
        path: filePath,
        stats: fs.existsSync(filePath) ? fs.statSync(filePath) : null,
    };
}
exports.createWatchEvent = createWatchEvent;
//# sourceMappingURL=directory-process-service.js.map