"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.STCBuilder = void 0;
const node_1 = require("@file-services/node");
const build_stylable_1 = require("./build-stylable");
const diagnostics_manager_1 = require("./diagnostics-manager");
const directory_process_service_1 = require("./directory-process-service/directory-process-service");
const logger_1 = require("./logger");
const index_internal_1 = require("@stylable/core/dist/index-internal");
const diagnostics = {
    INVALID_WATCH_HANDLER(method) {
        return `"${method}" called before the watchHandler is set, did you run build()?`;
    },
};
class STCBuilder {
    static create({ rootDir, fs = node_1.nodeFs, configFilePath, log = createNoopLogger(), watchMode = false, }) {
        return new this(rootDir, fs, configFilePath, log, watchMode);
    }
    constructor(rootDir, fs, configFilePath, log, watchMode) {
        this.rootDir = rootDir;
        this.fs = fs;
        this.configFilePath = configFilePath;
        this.log = log;
        this.watchMode = watchMode;
        this.diagnosticsMessages = new Map();
        /**
         * Provide the sources files for given output file path.
         * @param outputFilePath {string}
         */
        this.getSourcesFiles = (outputFilePath) => {
            return this.outputFiles?.get(outputFilePath);
        };
        /**
         * Executes a rebuild. It will build all files if "build" was never called or perform a rebuild of provided modified files.
         * Stylable saves information about the files that were built in each execution, then this can be used to rebuild only the relevant files.
         *
         * @param modifiedFiles {Iterable<string>} list of absolute file path that have been modified since the last build execution.
         */
        this.rebuild = async (modifiedFiles = []) => {
            if (this.watchHandler) {
                return this.rebuildModifiedFiles(modifiedFiles);
            }
            else {
                return this.build();
            }
        };
        /**
         * Executes a fresh build of the Stylable project.
         */
        this.build = async () => {
            const buildOutput = await (0, build_stylable_1.buildStylable)(this.rootDir, {
                diagnosticsManager: this.diagnosticsManager,
                log: this.log,
                configFilePath: this.configFilePath,
                watch: this.watchMode,
                watchOptions: {
                    lazy: true,
                },
            });
            this.watchHandler = buildOutput.watchHandler;
            this.outputFiles = buildOutput.outputFiles;
            this.projects = buildOutput.projects;
        };
        /**
         * Returns the absolute paths of the source directory that were resolved in the last build execution.
         * @returns {Iterable<string>} list of absolute directory path of the Stylable projects.
         */
        this.getProjectsSources = () => {
            const sourcesPaths = new Set();
            if (!this.projects) {
                return sourcesPaths;
            }
            for (const { projectRoot, options } of this.projects) {
                for (const optionEntity of options) {
                    sourcesPaths.add(this.fs.join(projectRoot, optionEntity.srcDir));
                }
            }
            return sourcesPaths;
        };
        /**
         * Reports diagnostics messages aggregated from the last build execution.
         * @param context {EmitDiagnosticsContext}
         * @param diagnosticsMode {DiagnosticsMode}
         */
        this.reportDiagnostics = (context, diagnosticsMode, remove = false) => {
            for (const [filePath] of this.diagnosticsMessages.entries()) {
                this.reportDiagnostic(filePath, context, diagnosticsMode, remove);
            }
        };
        /**
         * Reports diagnostics messages for a given file from the last build execution.
         * @param filePath {string}
         * @param context {EmitDiagnosticsContext}
         * @param diagnosticsMode {DiagnosticsMode}
         */
        this.reportDiagnostic = (filePath, context, diagnosticsMode, remove = false) => {
            const diagnostics = this.diagnosticsMessages.get(filePath);
            if (!diagnostics) {
                return;
            }
            for (const diagnostic of diagnostics) {
                (0, index_internal_1.reportDiagnostic)(context, diagnosticsMode, diagnostic, `${filePath}${diagnostic.line && diagnostic.column
                    ? `:${diagnostic.line}:${diagnostic.column}`
                    : ''}`);
            }
            if (remove) {
                this.diagnosticsMessages.delete(filePath);
            }
        };
        /**
         * Executes an incremental build of modified files.
         * @param modifiedFiles {Iterable<string>} list of absolute file path that have been modified since the last build execution.
         */
        this.rebuildModifiedFiles = async (modifiedFiles) => {
            if (!this.watchHandler) {
                throw createSTCBuilderError(diagnostics.INVALID_WATCH_HANDLER('handleWatchedFiles'));
            }
            for (const filePath of modifiedFiles) {
                const event = (0, directory_process_service_1.createWatchEvent)(this.fs.existsSync(filePath) ? this.fs.realpathSync(filePath) : filePath);
                await this.watchHandler.listener(event);
            }
        };
        this.diagnosticsManager = new diagnostics_manager_1.DiagnosticsManager({
            log: this.log,
            hooks: {
                preReport: (diagnosticsMessages) => {
                    /**
                     * Update the diagnostics messages every `build` execution.
                     */
                    this.diagnosticsMessages = new Map(diagnosticsMessages);
                },
            },
        });
    }
}
exports.STCBuilder = STCBuilder;
function createNoopLogger() {
    return (0, logger_1.createLogger)(() => {
        return;
    }, () => {
        return;
    });
}
function createSTCBuilderError(message) {
    return new Error(`Stylable Builder Error: ${message}`);
}
//# sourceMappingURL=stc-builder.js.map