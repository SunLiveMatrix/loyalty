"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDocumentFormatting = exports.formatDocumentExperimental = void 0;
const index_internal_1 = require("@stylable/core/dist/index-internal");
const js_beautify_1 = require("js-beautify");
const format_css_1 = require("./format-css");
/* new experimental formatter */
function formatDocumentExperimental(source, options) {
    // ToDo: support range
    let targetCss = source;
    try {
        targetCss = (0, format_css_1.formatCSS)(source, options);
    }
    catch (e) {
        // return unchanged source on error
    }
    return targetCss;
}
exports.formatDocumentExperimental = formatDocumentExperimental;
/* format with js-prettify */
function getDocumentFormatting(content, offset, options) {
    const offsetStart = offset?.start || 0;
    const offsetEnd = offset?.end || content.length;
    const ast = (0, index_internal_1.safeParse)(content.slice(offsetStart, offsetEnd));
    const changes = removeFormattingExceptions(ast);
    const formattedText = format(ast.toString(), options);
    const newText = restoreFormattingExceptions((0, index_internal_1.safeParse)(formattedText), changes).toString();
    return newText;
}
exports.getDocumentFormatting = getDocumentFormatting;
const stImport = 'st-import';
function removeFormattingExceptions(ast) {
    const atRuleChanges = [];
    const declChanges = [];
    // sanitizing @st-imports due to resulting broken formatting
    ast.walkAtRules(stImport, (atRule) => {
        atRuleChanges.push(atRule.params);
        atRule.params = 'temp';
    });
    ast.walkDecls(/^grid/, (decl) => {
        declChanges.push(decl.value);
        decl.value = `temp`;
    });
    return { atRuleChanges, declChanges };
}
function restoreFormattingExceptions(ast, { atRuleChanges, declChanges }) {
    ast.walkAtRules(stImport, (atRule) => {
        atRule.params = atRuleChanges.shift();
    });
    ast.walkDecls(/^grid/, (decl) => {
        decl.value = declChanges.shift();
    });
    return ast;
}
function format(text, options) {
    const normalizedOptions = {
        ...options,
        // hard-coded to prevent custom selector values starting with combinators from breaking
        space_around_combinator: true,
    };
    return (0, js_beautify_1.css)(text, normalizedOptions);
}
//# sourceMappingURL=formatter.js.map