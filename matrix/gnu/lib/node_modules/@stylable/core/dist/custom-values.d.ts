import type { ParsedValue } from './types';
export declare class CustomValueError extends Error {
    fallbackValue: string;
    constructor(message: string, fallbackValue: string);
}
export interface Box<Type extends string, Value> {
    type: Type;
    value: Value;
    flatValue: string | undefined;
}
export declare function box<Type extends string, Value>(type: Type, value: Value, flatValue?: string): Box<Type, Value>;
export declare function boxString(value: string): Box<"st-string", string>;
export declare function unbox<B extends Box<string, unknown>>(boxed: B | string, unboxPrimitives?: boolean, customValues?: CustomTypes, node?: ParsedValue): any;
export interface BoxedValueMap {
    [k: string]: string | Box<string, unknown>;
}
export type BoxedValueArray = Array<string | Box<string, unknown>>;
type CustomTypes = Record<string, CustomValueExtension<any>>;
export interface CustomValueExtension<T> {
    flattenValue?: FlattenValue<T>;
    evalVarAst(valueAst: ParsedValue, customTypes: {
        [typeID: string]: CustomValueExtension<unknown>;
    }, boxPrimitive?: boolean): Box<string, T>;
    getValue(path: string[], value: Box<string, T>, node: ParsedValue, customTypes: CustomTypes): string;
}
export declare const stTypes: CustomTypes;
export declare const deprecatedStFunctions: Record<string, {
    alternativeName: string;
}>;
export declare const CustomValueStrategy: {
    args: (fnNode: ParsedValue, customTypes: CustomTypes, boxPrimitive?: boolean) => any[];
    named: (fnNode: ParsedValue, customTypes: CustomTypes, boxPrimitive?: boolean) => BoxedValueMap;
};
export interface JSValueExtension<Value> {
    _kind: 'CustomValue';
    register(localTypeSymbol: string): CustomValueExtension<Value>;
}
type FlattenValue<Value> = (v: Box<string, Value>) => {
    parts: Array<string | Box<string, unknown>>;
    delimiter: ',' | ' ';
};
interface ExtensionApi<Value, Args> {
    processArgs: (fnNode: ParsedValue, customTypes: CustomTypes, boxPrimitive?: boolean) => Args;
    createValue: (args: Args) => Value;
    getValue: (v: Value, key: string) => string | Box<string, unknown>;
    flattenValue?: FlattenValue<Value>;
}
export declare function createCustomValue<Value, Args>({ processArgs, createValue, flattenValue, getValue, }: ExtensionApi<Value, Args>): JSValueExtension<Value>;
export declare function isCustomValue(symbol: any): symbol is JSValueExtension<unknown>;
export {};
//# sourceMappingURL=custom-values.d.ts.map