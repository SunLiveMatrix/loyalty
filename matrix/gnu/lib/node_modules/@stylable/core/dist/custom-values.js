"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isCustomValue = exports.createCustomValue = exports.CustomValueStrategy = exports.deprecatedStFunctions = exports.stTypes = exports.unbox = exports.boxString = exports.box = exports.CustomValueError = void 0;
const lodash_clonedeepwith_1 = __importDefault(require("lodash.clonedeepwith"));
const postcss_value_parser_1 = __importDefault(require("postcss-value-parser"));
const value_1 = require("./helpers/value");
class CustomValueError extends Error {
    constructor(message, fallbackValue) {
        super(message);
        this.fallbackValue = fallbackValue;
    }
}
exports.CustomValueError = CustomValueError;
function box(type, value, flatValue) {
    return {
        type,
        value,
        flatValue,
    };
}
exports.box = box;
function boxString(value) {
    return box('st-string', value, value);
}
exports.boxString = boxString;
function unbox(boxed, unboxPrimitives = true, customValues, node) {
    if (typeof boxed === 'string') {
        return unboxPrimitives ? boxed : boxString(boxed);
    }
    else if (typeof boxed === 'object' && boxed) {
        const customValue = customValues?.[boxed.type];
        let value = boxed.value;
        if (customValue?.flattenValue && node) {
            value = customValue.getValue([], boxed, node, customValues);
        }
        return (0, lodash_clonedeepwith_1.default)(value, (v) => unbox(v, unboxPrimitives, customValues, node));
    }
}
exports.unbox = unbox;
function createStArrayCustomFunction() {
    return createCustomValue({
        processArgs: (node, customTypes, boxPrimitive) => {
            return exports.CustomValueStrategy.args(node, customTypes, boxPrimitive);
        },
        createValue: (args) => {
            return args;
        },
        getValue: (value, index) => value[parseInt(index, 10)],
    });
}
function createStMapCustomFunction() {
    return createCustomValue({
        processArgs: (node, customTypes, boxPrimitive) => {
            return exports.CustomValueStrategy.named(node, customTypes, boxPrimitive);
        },
        createValue: (args) => {
            return args;
        },
        getValue: (value, index) => value[index],
    });
}
exports.stTypes = {
    /** @deprecated - use `st-array` */
    stArray: createStArrayCustomFunction().register('stArray'),
    /** @deprecated - use `st-map` */
    stMap: createStMapCustomFunction().register('stMap'),
    'st-array': createStArrayCustomFunction().register('st-array'),
    'st-map': createStMapCustomFunction().register('st-map'),
    'st-string': createStMapCustomFunction().register('st-string'),
};
exports.deprecatedStFunctions = {
    stArray: {
        alternativeName: 'st-array',
    },
    stMap: {
        alternativeName: 'st-map',
    },
};
exports.CustomValueStrategy = {
    args: (fnNode, customTypes, boxPrimitive) => {
        const pathArgs = (0, value_1.getFormatterArgs)(fnNode);
        const outputArray = [];
        for (const arg of pathArgs) {
            const parsedArg = (0, postcss_value_parser_1.default)(arg).nodes[0];
            const ct = parsedArg.type === 'function' && parsedArg.value;
            const resolvedValue = typeof ct === 'string' && customTypes[ct]
                ? customTypes[ct].evalVarAst(parsedArg, customTypes, boxPrimitive)
                : unbox(arg, !boxPrimitive);
            outputArray.push(resolvedValue);
        }
        return outputArray;
    },
    named: (fnNode, customTypes, boxPrimitive) => {
        const outputMap = {};
        const s = (0, value_1.getNamedArgs)(fnNode);
        for (const [prop, space, ...valueNodes] of s) {
            if (space.type !== 'space') {
                // TODO: error catch
                throw new Error('Invalid argument');
            }
            let resolvedValue;
            if (valueNodes.length === 0) {
                // TODO: error
            }
            else {
                const nonComments = valueNodes.filter((node) => node.type !== 'comment');
                if (nonComments.length === 1) {
                    const valueNode = nonComments[0];
                    resolvedValue = valueNode.resolvedValue;
                    if (!resolvedValue) {
                        const ct = customTypes[valueNode.value];
                        if (valueNode.type === 'function' && ct) {
                            resolvedValue = ct.evalVarAst(valueNode, customTypes, boxPrimitive);
                        }
                        else {
                            resolvedValue = unbox((0, value_1.getStringValue)(valueNode), !boxPrimitive);
                        }
                    }
                    else if (typeof resolvedValue === 'string') {
                        const parsedArg = (0, postcss_value_parser_1.default)(resolvedValue).nodes[0];
                        const ct = parsedArg.type === 'function' && parsedArg.value;
                        resolvedValue =
                            typeof ct === 'string' && customTypes[ct]
                                ? customTypes[ct].evalVarAst(parsedArg, customTypes, boxPrimitive)
                                : unbox(resolvedValue, !boxPrimitive);
                    }
                }
                else {
                    resolvedValue = unbox((0, value_1.getStringValue)(valueNodes), !boxPrimitive);
                }
            }
            if (resolvedValue) {
                outputMap[prop.value] = resolvedValue;
            }
        }
        return outputMap;
    },
};
function createCustomValue({ processArgs, createValue, flattenValue, getValue, }) {
    return {
        _kind: 'CustomValue',
        register(localTypeSymbol) {
            return {
                flattenValue,
                evalVarAst(fnNode, customTypes, boxPrimitive) {
                    const args = processArgs(fnNode, customTypes, boxPrimitive);
                    const value = createValue(args);
                    let flatValue;
                    if (flattenValue) {
                        flatValue = getFlatValue(flattenValue, box(localTypeSymbol, value), fnNode, customTypes);
                    }
                    return box(localTypeSymbol, value, flatValue);
                },
                getValue(path, obj, fallbackNode, // TODO: add test
                customTypes) {
                    if (path.length === 0) {
                        if (flattenValue) {
                            return getFlatValue(flattenValue, obj, fallbackNode, customTypes);
                        }
                        else {
                            const stringifiedValue = (0, value_1.getStringValue)([fallbackNode]);
                            throw new CustomValueError(`/* Error trying to flat -> */${stringifiedValue}`, stringifiedValue);
                        }
                    }
                    const value = getValue(obj.value, path[0]);
                    return getBoxValue(path.slice(1), value, fallbackNode, customTypes);
                },
            };
        },
    };
}
exports.createCustomValue = createCustomValue;
function getFlatValue(flattenValue, obj, fallbackNode, customTypes) {
    const { delimiter, parts } = flattenValue(obj);
    return parts.map((v) => getBoxValue([], v, fallbackNode, customTypes)).join(delimiter);
}
function getBoxValue(path, value, node, customTypes) {
    if (typeof value === 'string' || value.type === 'st-string') {
        return unbox(value, true, customTypes);
    }
    else if (value && customTypes[value.type]) {
        return customTypes[value.type].getValue(path, value, node, customTypes);
    }
    else {
        throw new Error('Unknown Type ' + JSON.stringify(value));
        // return JSON.stringify(value);
    }
}
function isCustomValue(symbol) {
    return symbol?._kind === 'CustomValue';
}
exports.isCustomValue = isCustomValue;
//# sourceMappingURL=custom-values.js.map