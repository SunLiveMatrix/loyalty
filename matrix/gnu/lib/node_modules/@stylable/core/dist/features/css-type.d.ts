import { FeatureContext } from './feature';
import type { ImportSymbol } from './st-import';
import * as CSSClass from './css-class';
import type { StylableMeta } from '../stylable-meta';
import type { Type, ImmutableType, ImmutableSelectorNode } from '@tokey/css-selector-parser';
import type * as postcss from 'postcss';
export interface ElementSymbol extends CSSClass.StPartDirectives {
    _kind: 'element';
    name: string;
    alias?: ImportSymbol;
}
export declare const diagnostics: {
    INVALID_FUNCTIONAL_SELECTOR: {
        (selector: string, type: string): import("../diagnostics").DiagnosticBase;
        code: string;
        severity: import("../diagnostics").DiagnosticSeverity;
    };
    UNSCOPED_TYPE_SELECTOR: {
        (name: string): import("../diagnostics").DiagnosticBase;
        code: string;
        severity: import("../diagnostics").DiagnosticSeverity;
    };
};
export declare const hooks: import("./feature").FeatureHooks<{
    SELECTOR: Type;
    IMMUTABLE_SELECTOR: ImmutableType;
}>;
export declare function get(meta: StylableMeta, name: string): ElementSymbol | undefined;
export declare function getAll(meta: StylableMeta): Record<string, ElementSymbol>;
export declare function createSymbol(input: Partial<ElementSymbol> & {
    name: string;
}): ElementSymbol;
export declare function addType(context: FeatureContext, name: string, rule?: postcss.Rule): ElementSymbol;
export declare function validateTypeScoping({ context, locallyScoped, reportUnscoped, node, nodes, index, rule, }: {
    context: FeatureContext;
    locallyScoped: boolean;
    reportUnscoped: boolean;
    node: ImmutableType;
    nodes: ImmutableSelectorNode[];
    index: number;
    rule: postcss.Rule;
}): boolean;
//# sourceMappingURL=css-type.d.ts.map