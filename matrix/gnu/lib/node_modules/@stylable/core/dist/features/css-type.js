"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateTypeScoping = exports.addType = exports.createSymbol = exports.getAll = exports.get = exports.hooks = exports.diagnostics = void 0;
const feature_1 = require("./feature");
const diagnostics_1 = require("./diagnostics");
const STSymbol = __importStar(require("./st-symbol"));
const CSSClass = __importStar(require("./css-class"));
const selector_1 = require("../helpers/selector");
const resolve_1 = require("../helpers/resolve");
const diagnostics_2 = require("../diagnostics");
exports.diagnostics = {
    INVALID_FUNCTIONAL_SELECTOR: diagnostics_1.generalDiagnostics.INVALID_FUNCTIONAL_SELECTOR,
    UNSCOPED_TYPE_SELECTOR: (0, diagnostics_2.createDiagnosticReporter)(`03001`, 'warning', (name) => `unscoped type selector "${name}" will affect all elements of the same type in the document`),
};
// HOOKS
exports.hooks = (0, feature_1.createFeature)({
    analyzeSelectorNode({ context, node, rule, walkContext: [_index, _nodes] }) {
        if (node.nodes) {
            // error on functional type
            context.diagnostics.report(exports.diagnostics.INVALID_FUNCTIONAL_SELECTOR(node.value, `type`), {
                node: rule,
                word: (0, selector_1.stringifySelector)(node),
            });
        }
        addType(context, node.value, rule);
    },
    transformSelectorNode({ context, node, selectorContext }) {
        const resolvedSymbols = context.getResolvedSymbols(context.meta);
        let resolved = resolvedSymbols.element[node.value];
        if (!resolved) {
            const resolvedClass = resolvedSymbols.class[node.value];
            if (resolvedClass?.length > 1 && resolvedClass[0].symbol.alias) {
                // fallback to imported class alias for case that no actual
                // type selector was found in the source rules, but transform is
                // called with such selector externally (this happens for invalid selectors
                // during language service completions)
                resolved = resolvedSymbols.class[node.value];
            }
            else {
                // provides resolution for native elements
                // that are not collected by parts
                // or elements that are added by js mixin
                resolved = [
                    {
                        _kind: 'css',
                        meta: context.meta,
                        symbol: createSymbol({ name: '*' }),
                    },
                ];
            }
        }
        selectorContext.setNextSelectorScope(resolved, node, node.value);
        // native node does not resolve e.g. div
        if (selectorContext.transform && resolved && resolved.length > 1) {
            const { symbol, meta } = (0, resolve_1.getOriginDefinition)(resolved);
            if (symbol._kind === 'class') {
                CSSClass.namespaceClass(meta, symbol, node);
            }
            else {
                node.value = symbol.name;
            }
        }
    },
});
// API
function get(meta, name) {
    return STSymbol.get(meta, name, `element`);
}
exports.get = get;
function getAll(meta) {
    return STSymbol.getAllByType(meta, `element`);
}
exports.getAll = getAll;
function createSymbol(input) {
    const parts = input['-st-parts'] || {};
    return { ...input, _kind: 'element', '-st-parts': parts };
}
exports.createSymbol = createSymbol;
function addType(context, name, rule) {
    const typeSymbol = STSymbol.get(context.meta, name, `element`);
    if (!typeSymbol && (0, selector_1.isCompRoot)(name)) {
        let alias = STSymbol.get(context.meta, name);
        if (alias && alias._kind !== 'import') {
            alias = undefined;
        }
        STSymbol.addSymbol({
            context,
            symbol: createSymbol({ name, alias }),
            node: rule,
            safeRedeclare: !!alias,
        });
    }
    return STSymbol.get(context.meta, name, `element`);
}
exports.addType = addType;
function validateTypeScoping({ context, locallyScoped, reportUnscoped, node, nodes, index, rule, }) {
    if (context.meta.type !== 'stylable') {
        // ignore in native CSS
        return true;
    }
    if (locallyScoped === false) {
        if (CSSClass.checkForScopedNodeAfter(context, rule, nodes, index) === false) {
            if (reportUnscoped) {
                context.diagnostics.report(exports.diagnostics.UNSCOPED_TYPE_SELECTOR(node.value), {
                    node: rule,
                    word: node.value,
                });
            }
            return false;
        }
        else {
            locallyScoped = true;
        }
    }
    return locallyScoped;
}
exports.validateTypeScoping = validateTypeScoping;
//# sourceMappingURL=css-type.js.map