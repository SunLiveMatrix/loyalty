import * as STSymbol from './st-symbol';
import type { ImportSymbol } from './st-import';
import type { ElementSymbol } from './css-type';
import type { ClassSymbol } from './css-class';
import * as postcss from 'postcss';
import { FunctionNode, WordNode } from 'postcss-value-parser';
import type { StylableMeta } from '../stylable-meta';
import { Diagnostics } from '../diagnostics';
import type { Stylable } from '../stylable';
export interface MixinValue {
    type: string;
    options: Array<{
        value: string;
    }> | Record<string, string>;
    partial?: boolean;
    valueNode?: FunctionNode | WordNode;
    originDecl: postcss.Declaration;
}
export type ValidMixinSymbols = ImportSymbol | ClassSymbol | ElementSymbol;
export type AnalyzedMixin = {
    valid: true;
    data: MixinValue;
    symbol: ValidMixinSymbols;
} | {
    valid: false;
    data: MixinValue;
    symbol: Exclude<STSymbol.StylableSymbol, ValidMixinSymbols> | undefined;
};
export type MixinReflection = {
    name: string;
    kind: 'css-fragment';
    args: Record<string, string>[];
    optionalArgs: Map<string, {
        name: string;
    }>;
} | {
    name: string;
    kind: 'js-func';
    args: string[];
    func: (...args: any[]) => any;
} | {
    name: string;
    kind: 'invalid';
    args: string;
};
export declare const MixinType: {
    ALL: "-st-mixin";
    PARTIAL: "-st-partial-mixin";
};
export declare const diagnostics: {
    VALUE_CANNOT_BE_STRING: {
        (): import("../diagnostics").DiagnosticBase;
        code: string;
        severity: import("../diagnostics").DiagnosticSeverity;
    };
    INVALID_NAMED_PARAMS: {
        (): import("../diagnostics").DiagnosticBase;
        code: string;
        severity: import("../diagnostics").DiagnosticSeverity;
    };
    INVALID_MERGE_OF: {
        (mergeValue: string): import("../diagnostics").DiagnosticBase;
        code: string;
        severity: import("../diagnostics").DiagnosticSeverity;
    };
    INVALID_RECURSIVE_MIXIN: {
        (): import("../diagnostics").DiagnosticBase;
        code: string;
        severity: import("../diagnostics").DiagnosticSeverity;
    };
    PARTIAL_MIXIN_MISSING_ARGUMENTS: {
        (type: string): import("../diagnostics").DiagnosticBase;
        code: string;
        severity: import("../diagnostics").DiagnosticSeverity;
    };
    UNKNOWN_MIXIN: {
        (name: string): import("../diagnostics").DiagnosticBase;
        code: string;
        severity: import("../diagnostics").DiagnosticSeverity;
    };
    OVERRIDE_MIXIN: {
        (mixinType: string): import("../diagnostics").DiagnosticBase;
        code: string;
        severity: import("../diagnostics").DiagnosticSeverity;
    };
    FAILED_TO_APPLY_MIXIN: {
        (error: string): import("../diagnostics").DiagnosticBase;
        code: string;
        severity: import("../diagnostics").DiagnosticSeverity;
    };
    JS_MIXIN_NOT_A_FUNC: {
        (): import("../diagnostics").DiagnosticBase;
        code: string;
        severity: import("../diagnostics").DiagnosticSeverity;
    };
    UNSUPPORTED_MIXIN_SYMBOL: {
        (name: string, symbolType: "element" | "container" | "var" | "class" | "layer" | "import" | "cssVar" | "keyframes"): import("../diagnostics").DiagnosticBase;
        code: string;
        severity: import("../diagnostics").DiagnosticSeverity;
    };
    CIRCULAR_MIXIN: {
        (circularPaths: string[]): import("../diagnostics").DiagnosticBase;
        code: string;
        severity: import("../diagnostics").DiagnosticSeverity;
    };
    UNKNOWN_ARG: {
        (argName: any): import("../diagnostics").DiagnosticBase;
        code: string;
        severity: import("../diagnostics").DiagnosticSeverity;
    };
};
export declare const hooks: import("./feature").FeatureHooks<import("./feature").NodeTypes>;
export declare class StylablePublicApi {
    private stylable;
    constructor(stylable: Stylable);
    resolveExpr(meta: StylableMeta, expr: string, { diagnostics, resolveOptionalArgs, }?: {
        diagnostics?: Diagnostics;
        resolveOptionalArgs?: boolean;
    }): MixinReflection[];
    scopeNestedSelector(scopeSelector: string, nestSelector: string): string;
}
//# sourceMappingURL=st-mixin.d.ts.map