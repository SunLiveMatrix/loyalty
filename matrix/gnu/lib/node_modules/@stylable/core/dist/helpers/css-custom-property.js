"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateScopedCSSVar = exports.validateCustomPropertyName = exports.validateAtProperty = exports.atPropertyValidationWarnings = void 0;
const diagnostics_1 = require("../diagnostics");
const string_1 = require("../helpers/string");
const UNIVERSAL_SYNTAX_DEFINITION = '*';
const AT_PROPERTY_DISCRIPTOR_LIST = ['initial-value', 'syntax', 'inherits'];
exports.atPropertyValidationWarnings = {
    MISSING_REQUIRED_DESCRIPTOR: (0, diagnostics_1.createDiagnosticReporter)('01001', 'error', (descriptorName) => `@property rules require a "${descriptorName}" descriptor`),
    MISSING_REQUIRED_INITIAL_VALUE_DESCRIPTOR: (0, diagnostics_1.createDiagnosticReporter)('01002', 'warning', () => '@property "initial-value" descriptor is optional only if the "syntax" is the universal syntax definition, otherwise the descriptor is required'),
    INVALID_DESCRIPTOR_TYPE: (0, diagnostics_1.createDiagnosticReporter)('01003', 'error', (descriptorType) => `@property does not support descriptor of type "${descriptorType}"`),
    INVALID_DESCRIPTOR_NAME: (0, diagnostics_1.createDiagnosticReporter)('01004', 'error', (descriptorName) => `@property does not support descriptor named "${descriptorName}"`),
};
function validateAtProperty(atRule, diagnostics) {
    const name = atRule.params;
    const atPropertyValues = new Map();
    if (!atRule.nodes?.length) {
        return {
            valid: true,
        };
    }
    for (const node of atRule.nodes) {
        if (node.type !== 'decl') {
            if (node.type === 'atrule' || node.type === 'rule') {
                diagnostics.report(exports.atPropertyValidationWarnings.INVALID_DESCRIPTOR_TYPE(node.type), {
                    node,
                    word: 'params' in node ? node.params : node.selector,
                });
            }
            continue;
        }
        if (!AT_PROPERTY_DISCRIPTOR_LIST.includes(node.prop)) {
            diagnostics.report(exports.atPropertyValidationWarnings.INVALID_DESCRIPTOR_NAME(node.prop), {
                node,
                word: node.prop,
            });
            continue;
        }
        atPropertyValues.set(node.prop, (0, string_1.stripQuotation)(node.value));
    }
    if (!atPropertyValues.has('syntax')) {
        diagnostics.report(exports.atPropertyValidationWarnings.MISSING_REQUIRED_DESCRIPTOR('syntax'), {
            node: atRule,
            word: name,
        });
        return {
            valid: false,
        };
    }
    if (!atPropertyValues.has('inherits')) {
        diagnostics.report(exports.atPropertyValidationWarnings.MISSING_REQUIRED_DESCRIPTOR('inherits'), {
            node: atRule,
            word: name,
        });
        return {
            valid: false,
        };
    }
    if (!atPropertyValues.has('initial-value') &&
        atPropertyValues.get('syntax') !== UNIVERSAL_SYNTAX_DEFINITION) {
        diagnostics.report(exports.atPropertyValidationWarnings.MISSING_REQUIRED_INITIAL_VALUE_DESCRIPTOR(), {
            node: atRule,
            word: name,
        });
        return {
            valid: false,
        };
    }
    return {
        valid: true,
    };
}
exports.validateAtProperty = validateAtProperty;
function validateCustomPropertyName(value) {
    return value.startsWith('--');
}
exports.validateCustomPropertyName = validateCustomPropertyName;
function generateScopedCSSVar(namespace, varName) {
    return `--${namespace}-${varName}`;
}
exports.generateScopedCSSVar = generateScopedCSSVar;
//# sourceMappingURL=css-custom-property.js.map