"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.findValueAstNode = exports.findNextCallNode = exports.findCustomIdent = exports.findLiteral = exports.findPseudoElementNode = exports.findNextPseudoClassNode = exports.findNextClassNode = exports.isExactLiteral = exports.findFatArrow = exports.findAnything = void 0;
function findAnything(value, startIndex, options) {
    return findValueAstNode(value, startIndex, () => true, options);
}
exports.findAnything = findAnything;
function findFatArrow(value, startIndex, options) {
    const [amountToEql, _eqlNode, eqlNodeInspectAmount] = findLiteral(value, startIndex, {
        ...options,
        name: '=',
    });
    if (amountToEql) {
        const nextNode = value[startIndex + amountToEql];
        if (isExactLiteral(nextNode, '>')) {
            return [amountToEql + 1, nextNode, amountToEql + 1];
        }
    }
    return [0, undefined, eqlNodeInspectAmount];
}
exports.findFatArrow = findFatArrow;
function isExactLiteral(token, name) {
    return token && token.type === 'literal' && token.value === name;
}
exports.isExactLiteral = isExactLiteral;
function findNextClassNode(value, startIndex, options) {
    const name = options?.name || '';
    let index = startIndex;
    while (index < value.length) {
        const [amountToDot, _dotNode] = findLiteral(value, index, { ...options, name: '.' });
        if (amountToDot) {
            index += amountToDot;
            const [amountToName, nameNode] = findCustomIdent(value, index, {
                name,
                stopOnFail: true,
            });
            if (amountToName) {
                return [amountToDot + amountToName, nameNode, index - startIndex + 1];
            }
        }
        if (options?.stopOnFail) {
            break;
        }
        index++;
    }
    return [0, undefined, value.length - startIndex];
}
exports.findNextClassNode = findNextClassNode;
function findNextPseudoClassNode(value, startIndex, options) {
    const name = options?.name || '';
    let index = startIndex;
    while (index < value.length) {
        const [amountToColon] = findLiteral(value, index, { ...options, name: ':' });
        if (amountToColon) {
            index += amountToColon;
            const nameOptions = {
                name,
                stopOnFail: true,
                ignoreComments: true,
                ignoreWhitespace: false,
            };
            const [amountToName, nameNode] = findCustomIdent(value, index, nameOptions);
            if (amountToName) {
                return [amountToColon + amountToName, nameNode, index - startIndex + 1];
            }
            else {
                const [amountToCall, callNode] = findNextCallNode(value, index, nameOptions);
                if (amountToCall) {
                    return [amountToColon + amountToCall, callNode, index - startIndex + 1];
                }
                else {
                    break;
                }
            }
        }
        else if (options?.stopOnFail) {
            break;
        }
        else {
            index++;
        }
    }
    return [0, undefined, value.length - startIndex];
}
exports.findNextPseudoClassNode = findNextPseudoClassNode;
function findPseudoElementNode(value, startIndex, options) {
    let index = startIndex;
    while (index < value.length) {
        // first colon
        const [amountToColon] = findLiteral(value, index, { ...options, name: ':' }); // second colon
        if (amountToColon) {
            index += amountToColon; // name
            const [amountToSecondColon] = findLiteral(value, index, {
                ...options,
                name: ':',
                stopOnFail: true,
                ignoreWhitespace: false,
            });
            if (amountToSecondColon) {
                index += amountToSecondColon;
                const [amountToName, nameNode] = findCustomIdent(value, index, {
                    ...options,
                    stopOnFail: true,
                });
                if (nameNode) {
                    return [
                        index - startIndex + amountToName,
                        nameNode,
                        index - startIndex + amountToName,
                    ];
                }
            }
        }
        if (options?.stopOnFail) {
            break;
        }
        index++;
    }
    return [0, undefined, index - startIndex];
}
exports.findPseudoElementNode = findPseudoElementNode;
function findLiteral(value, startIndex, options) {
    const name = options?.name || '';
    return findValueAstNode(value, startIndex, (node) => node.type === 'literal' && (!name || node.value === name), options);
}
exports.findLiteral = findLiteral;
function findCustomIdent(value, startIndex, options) {
    const name = options?.name || '';
    return findValueAstNode(value, startIndex, (node) => node.type === '<custom-ident>' && (!name || node.value === name), options);
}
exports.findCustomIdent = findCustomIdent;
function findNextCallNode(value, startIndex, options) {
    const name = options?.name || '';
    return findValueAstNode(value, startIndex, (node) => node.type === 'call' && (!name || node.value === name), options);
}
exports.findNextCallNode = findNextCallNode;
function findValueAstNode(valueAst, startIndex, check, { stopOnFail = true, ignoreWhitespace = true, ignoreComments = true, stopOnMatch, } = {}) {
    let index = startIndex;
    while (index < valueAst.length) {
        const node = valueAst[index];
        if (ignoreComments && node.type === 'comment') {
            // continue;
        }
        else if (ignoreWhitespace && node.type === 'space') {
            // continue;
        }
        else if (check(node)) {
            return [index - startIndex + 1, node, index - startIndex + 1];
        }
        else if (stopOnFail || stopOnMatch?.(node, index, valueAst)) {
            break;
        }
        index++;
    }
    return [0, undefined, index - startIndex];
}
exports.findValueAstNode = findValueAstNode;
//# sourceMappingURL=css-value-seeker.js.map