import type * as postcss from 'postcss';
import type { PseudoClass } from '@tokey/css-selector-parser';
import { Diagnostics } from '../diagnostics';
import type { StylableMeta } from '../stylable-meta';
import type { StylableResolver } from '../stylable-resolver';
import { BaseAstNode } from '@tokey/css-value-parser';
export interface MappedStates {
    [s: string]: StateParsedValue | string | TemplateStateParsedValue | null;
}
export interface TemplateStateParsedValue {
    type: 'template';
    template: string;
    params: [StateParsedValue];
}
export interface StateParsedValue {
    type: string;
    defaultValue?: string;
    arguments: StateArguments;
}
export interface StateTypeValidator {
    name: string;
    args: string[];
}
type StateArguments = Array<StateTypeValidator | string>;
export declare const stateMiddleDelimiter = "-";
export declare const booleanStateDelimiter = "--";
export declare const stateWithParamDelimiter: string;
export declare const stateDiagnostics: {
    MISSING_TYPE_OR_TEMPLATE: {
        (name: string): import("../diagnostics").DiagnosticBase;
        code: string;
        severity: import("../diagnostics").DiagnosticSeverity;
    };
    UNKNOWN_STATE_TYPE: {
        (name: string, type: string): import("../diagnostics").DiagnosticBase;
        code: string;
        severity: import("../diagnostics").DiagnosticSeverity;
    };
    TOO_MANY_STATE_TYPES: {
        (name: string, types: string[]): import("../diagnostics").DiagnosticBase;
        code: string;
        severity: import("../diagnostics").DiagnosticSeverity;
    };
    NO_STATE_TYPE_GIVEN: {
        (name: string): import("../diagnostics").DiagnosticBase;
        code: string;
        severity: import("../diagnostics").DiagnosticSeverity;
    };
    TOO_MANY_ARGS_IN_VALIDATOR: {
        (name: string, validator: string, args: string[]): import("../diagnostics").DiagnosticBase;
        code: string;
        severity: import("../diagnostics").DiagnosticSeverity;
    };
    STATE_STARTS_WITH_HYPHEN: {
        (name: string): import("../diagnostics").DiagnosticBase;
        code: string;
        severity: import("../diagnostics").DiagnosticSeverity;
    };
    RESERVED_NATIVE_STATE: {
        (name: string): import("../diagnostics").DiagnosticBase;
        code: string;
        severity: import("../diagnostics").DiagnosticSeverity;
    };
    DEFAULT_PARAM_FAILS_VALIDATION: {
        (stateName: string, defaultValue: string, errors: string[]): import("../diagnostics").DiagnosticBase;
        code: string;
        severity: import("../diagnostics").DiagnosticSeverity;
    };
    NO_STATE_ARGUMENT_GIVEN: {
        (name: string, type: string): import("../diagnostics").DiagnosticBase;
        code: string;
        severity: import("../diagnostics").DiagnosticSeverity;
    };
    FAILED_STATE_VALIDATION: {
        (name: string, actualParam: string, errors: string[]): import("../diagnostics").DiagnosticBase;
        code: string;
        severity: import("../diagnostics").DiagnosticSeverity;
    };
    TEMPLATE_MISSING_PLACEHOLDER: {
        (state: string, template: string): import("../diagnostics").DiagnosticBase;
        code: string;
        severity: import("../diagnostics").DiagnosticSeverity;
    };
    TEMPLATE_MULTI_PARAMETERS: {
        (state: string): import("../diagnostics").DiagnosticBase;
        code: string;
        severity: import("../diagnostics").DiagnosticSeverity;
    };
    TEMPLATE_MISSING_PARAMETER: {
        (state: string): import("../diagnostics").DiagnosticBase;
        code: string;
        severity: import("../diagnostics").DiagnosticSeverity;
    };
    UNSUPPORTED_MULTI_SELECTOR: {
        (state: string, finalSelector: string): import("../diagnostics").DiagnosticBase;
        code: string;
        severity: import("../diagnostics").DiagnosticSeverity;
    };
    UNSUPPORTED_COMPLEX_SELECTOR: {
        (state: string, finalSelector: string): import("../diagnostics").DiagnosticBase;
        code: string;
        severity: import("../diagnostics").DiagnosticSeverity;
    };
    INVALID_SELECTOR: {
        (state: string, finalSelector: string): import("../diagnostics").DiagnosticBase;
        code: string;
        severity: import("../diagnostics").DiagnosticSeverity;
    };
    UNSUPPORTED_INITIAL_SELECTOR: {
        (state: string, finalSelector: string): import("../diagnostics").DiagnosticBase;
        code: string;
        severity: import("../diagnostics").DiagnosticSeverity;
    };
    NO_PARAM_REQUIRED: {
        (name: string, param: string): import("../diagnostics").DiagnosticBase;
        code: string;
        severity: import("../diagnostics").DiagnosticSeverity;
    };
};
export declare function parsePseudoStates(value: string, decl: postcss.Declaration, diagnostics: Diagnostics): MappedStates;
export declare function parseStateValue(value: BaseAstNode[], node: postcss.Node, diagnostics: Diagnostics): [amountTaken: number, stateDef: MappedStates[string] | undefined];
export interface StateResult {
    res: string;
    errors: string[] | null;
}
export declare const validationErrors: {
    string: {
        STRING_TYPE_VALIDATION_FAILED: (actualParam: string) => string;
        REGEX_VALIDATION_FAILED: (regex: string, actualParam: string) => string;
        CONTAINS_VALIDATION_FAILED: (shouldContain: string, actualParam: string) => string;
        MIN_LENGTH_VALIDATION_FAILED: (length: string, actualParam: string) => string;
        MAX_LENGTH_VALIDATION_FAILED: (length: string, actualParam: string) => string;
        UKNOWN_VALIDATOR: (name: string) => string;
    };
    number: {
        NUMBER_TYPE_VALIDATION_FAILED: (actualParam: string) => string;
        MIN_VALIDATION_FAILED: (actualParam: string, min: string) => string;
        MAX_VALIDATION_FAILED: (actualParam: string, max: string) => string;
        MULTIPLE_OF_VALIDATION_FAILED: (actualParam: string, multipleOf: string) => string;
        UKNOWN_VALIDATOR: (name: string) => string;
    };
    enum: {
        ENUM_TYPE_VALIDATION_FAILED: (actualParam: string, options: string[]) => string;
        NO_OPTIONS_DEFINED: () => string;
    };
};
export type SubValidator = (value: string, ...rest: string[]) => StateResult;
export interface StateParamType {
    subValidators?: Record<string, SubValidator>;
    validate(value: any, args: StateArguments, resolveParam: any, validateDefinition: boolean, validateValue: boolean): StateResult;
}
export declare const systemValidators: Record<string, StateParamType>;
export declare function validateRuleStateDefinition(selector: string, selectorNode: postcss.Rule | postcss.AtRule, meta: StylableMeta, resolver: StylableResolver, diagnostics: Diagnostics): void;
export declare function validateStateArgument(stateAst: StateParsedValue, meta: StylableMeta, value: string, resolver: StylableResolver, diagnostics: Diagnostics, selectorNode?: postcss.Node, validateDefinition?: boolean, validateValue?: boolean): StateResult;
export declare function transformPseudoClassToCustomState(stateDef: MappedStates[string], meta: StylableMeta, name: string, stateNode: PseudoClass, namespace: string, resolver: StylableResolver, diagnostics: Diagnostics, selectorNode?: postcss.Node): void;
export declare function isTemplateState(state: MappedStates[string]): state is TemplateStateParsedValue;
export declare function createBooleanStateClassName(stateName: string, namespace: string): string;
export declare function createStateWithParamClassName(stateName: string, namespace: string, param: string): string;
export declare function resolveStateParam(param: string, escape?: boolean): string;
export {};
//# sourceMappingURL=custom-state.d.ts.map