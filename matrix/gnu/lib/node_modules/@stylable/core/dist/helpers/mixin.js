"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseStPartialMixin = exports.parseStMixin = exports.mixinHelperDiagnostics = void 0;
const diagnostics_1 = require("../diagnostics");
const value_1 = require("./value");
const postcss_value_parser_1 = __importDefault(require("postcss-value-parser"));
exports.mixinHelperDiagnostics = {
    INVALID_NAMED_PARAMS: value_1.valueDiagnostics.INVALID_NAMED_PARAMS,
    VALUE_CANNOT_BE_STRING: (0, diagnostics_1.createDiagnosticReporter)('10008', 'error', () => 'value can not be a string (remove quotes?)'),
};
function parseStMixin(mixinNode, strategy, diagnostics, emitStrategyDiagnostics = true) {
    const ast = (0, postcss_value_parser_1.default)(mixinNode.value);
    const mixins = [];
    function reportWarning(diagnostic, options) {
        if (emitStrategyDiagnostics) {
            diagnostics?.report(diagnostic, { ...options, node: mixinNode });
        }
    }
    ast.nodes.forEach((node) => {
        if (node.type === 'function') {
            mixins.push({
                type: node.value,
                options: value_1.strategies[strategy(node.value)](node, reportWarning),
                valueNode: node,
                originDecl: mixinNode,
            });
        }
        else if (node.type === 'word') {
            mixins.push({
                type: node.value,
                options: strategy(node.value) === 'named' ? {} : [],
                valueNode: node,
                originDecl: mixinNode,
            });
        }
        else if (node.type === 'string') {
            diagnostics?.report(exports.mixinHelperDiagnostics.VALUE_CANNOT_BE_STRING(), {
                node: mixinNode,
                word: mixinNode.value,
            });
        }
    });
    return mixins;
}
exports.parseStMixin = parseStMixin;
function parseStPartialMixin(mixinNode, strategy, report, emitStrategyDiagnostics) {
    return parseStMixin(mixinNode, strategy, report, emitStrategyDiagnostics).map((mixin) => {
        mixin.partial = true;
        return mixin;
    });
}
exports.parseStPartialMixin = parseStPartialMixin;
//# sourceMappingURL=mixin.js.map