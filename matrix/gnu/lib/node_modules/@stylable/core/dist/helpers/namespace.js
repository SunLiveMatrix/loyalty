"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createNamespaceStrategy = exports.defaultNoMatchHandler = exports.defaultNamespaceBuilder = exports.namespace = exports.namespaceDelimiter = void 0;
const murmurhash_1 = require("../murmurhash");
exports.namespaceDelimiter = '__';
function namespace(name, namespace) {
    return namespace ? namespace + exports.namespaceDelimiter + name : name;
}
exports.namespace = namespace;
function defaultGetPackageInfo() {
    return {
        name: '',
        version: '0.0.0',
        dirPath: '',
    };
}
function defaultNamespaceBuilder({ prefix, namespace, hashSalt, paths, packageInfo, }) {
    return {
        namespace: prefix + namespace,
        hashPart: hashSalt + packageInfo.name + '@' + packageInfo.version + '/' + paths.origin,
    };
}
exports.defaultNamespaceBuilder = defaultNamespaceBuilder;
function defaultNoMatchHandler(strict, ns, stylesheetPath, usedBy) {
    throw new Error(`Could not create namespace for:\n${stylesheetPath}\nthe last valid namespace tried was ${JSON.stringify(ns)}${usedBy ? ` that was used by:\n${usedBy}\n` : strict ? ' ' : ''}${strict ? 'running on strict mode' : ''}`);
}
exports.defaultNoMatchHandler = defaultNoMatchHandler;
function createNamespaceStrategy(options) {
    const { prefix = '', hashSalt = '', hashFragment = 'minimal', buildNamespace = defaultNamespaceBuilder, getPackageInfo = defaultGetPackageInfo, handleNoMatch = defaultNoMatchHandler, hashSeparator = '-', strict = false, hashFn = murmurhash_1.murmurhash3_32_gc, normalizePath, } = options;
    const usedNamespaces = new Map();
    return (namespace, stylesheetOriginPath, stylesheetPath = stylesheetOriginPath) => {
        const packageInfo = getPackageInfo(stylesheetPath);
        const buildNamespaceParams = {
            prefix,
            hashSalt,
            namespace,
            paths: {
                file: packageInfo.dirPath
                    ? normalizePath(packageInfo.dirPath, stylesheetPath)
                    : stylesheetPath,
                origin: packageInfo.dirPath
                    ? normalizePath(packageInfo.dirPath, stylesheetOriginPath)
                    : stylesheetOriginPath,
            },
            packageInfo,
        };
        const { namespace: resultNs, hashPart } = buildNamespace(buildNamespaceParams) ?? defaultNamespaceBuilder(buildNamespaceParams);
        const hashStr = hashFn(hashPart).toString();
        let i = typeof hashFragment === 'number'
            ? hashFragment
            : hashFragment === 'full'
                ? hashStr.length
                : 0;
        let finalNamespace = '';
        while (i <= hashStr.length) {
            const hashSlice = hashStr.slice(0, i);
            finalNamespace = resultNs + (hashSlice ? hashSeparator + hashSlice : '');
            const usedBy = usedNamespaces.get(finalNamespace);
            if (!usedBy) {
                usedNamespaces.set(finalNamespace, stylesheetPath);
                return finalNamespace;
            }
            if (usedBy === stylesheetPath) {
                return finalNamespace;
            }
            else if (strict) {
                return handleNoMatch(strict, finalNamespace, stylesheetPath, usedBy);
            }
            i++;
        }
        return handleNoMatch(strict, finalNamespace, stylesheetPath, usedNamespaces.get(finalNamespace));
    };
}
exports.createNamespaceStrategy = createNamespaceStrategy;
//# sourceMappingURL=namespace.js.map