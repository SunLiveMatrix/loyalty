"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.strategies = exports.validateAllowedNodesUntil = exports.groupValues = exports.listOptions = exports.getStringValue = exports.getFormatterArgs = exports.stringifyFunction = exports.getNamedArgs = exports.valueDiagnostics = void 0;
const postcss_value_parser_1 = __importDefault(require("postcss-value-parser"));
const diagnostics_1 = require("../diagnostics");
exports.valueDiagnostics = {
    INVALID_NAMED_PARAMS: (0, diagnostics_1.createDiagnosticReporter)('13001', 'error', () => `invalid named parameters (e.g. "func(name value, [name value, ...])")`),
    MISSING_REQUIRED_FORMATTER_ARG: (0, diagnostics_1.createDiagnosticReporter)('13002', 'error', (node, argIndex) => `${postcss_value_parser_1.default.stringify(node)}: argument at index ${argIndex} is empty`),
};
function getNamedArgs(node) {
    const args = [];
    if (node.nodes.length) {
        args.push([]);
        node.nodes.forEach((node) => {
            if (node.type === 'div') {
                args.push([]);
            }
            else {
                const { sourceIndex: _sourceIndex, sourceEndIndex: _sourceEndIndex, ...clone } = node;
                args[args.length - 1].push(clone);
            }
        });
    }
    // handle trailing comma
    return args.length && args[args.length - 1].length === 0 ? args.slice(0, -1) : args;
}
exports.getNamedArgs = getNamedArgs;
function stringifyFunction(name, parsedNode, perserveQuotes = false) {
    return `${name}(${getFormatterArgs(parsedNode, false, undefined, perserveQuotes).join(', ')})`;
}
exports.stringifyFunction = stringifyFunction;
function getFormatterArgs(node, allowComments = false, reportWarning, preserveQuotes = false) {
    const argsResult = [];
    let currentArg = '';
    let argIndex = 0;
    for (const currentNode of node.nodes) {
        if (currentNode.type === 'div' && currentNode.value === ',') {
            checkEmptyArg();
            argIndex++;
            argsResult.push(currentArg.trim());
            currentArg = '';
        }
        else if (currentNode.type === 'comment') {
            if (allowComments) {
                currentArg +=
                    currentNode.resolvedValue || postcss_value_parser_1.default.stringify(currentNode);
            }
        }
        else if (currentNode.type === 'string') {
            currentArg += preserveQuotes
                ? postcss_value_parser_1.default.stringify(currentNode)
                : currentNode.value;
        }
        else {
            currentArg += currentNode.resolvedValue || postcss_value_parser_1.default.stringify(currentNode);
        }
    }
    checkEmptyArg();
    argsResult.push(currentArg.trim());
    let i = argsResult.length;
    while (i--) {
        if (argsResult[i] === '') {
            argsResult.pop();
        }
        else {
            return argsResult;
        }
    }
    return argsResult;
    function checkEmptyArg() {
        if (reportWarning && argsResult.length && currentArg.trim() === '') {
            reportWarning(exports.valueDiagnostics.MISSING_REQUIRED_FORMATTER_ARG(node, argIndex));
        }
    }
}
exports.getFormatterArgs = getFormatterArgs;
function getStringValue(nodes) {
    return postcss_value_parser_1.default.stringify(nodes, (node) => {
        if (node.resolvedValue !== undefined) {
            return node.resolvedValue;
        }
        else {
            // TODO: warn
            return undefined;
        }
    });
}
exports.getStringValue = getStringValue;
function listOptions(node) {
    return groupValues(node.nodes)
        .map((nodes) => postcss_value_parser_1.default.stringify(nodes, (n) => {
        if (n.type === 'div') {
            return null;
        }
        else if (n.type === 'string') {
            return n.value;
        }
        else {
            return undefined;
        }
    }))
        .filter((x) => typeof x === 'string');
}
exports.listOptions = listOptions;
function groupValues(nodes, divType = 'div') {
    const grouped = [];
    let current = [];
    nodes.forEach((n) => {
        if (n.type === divType) {
            grouped.push(current);
            current = [];
        }
        else {
            current.push(n);
        }
    });
    const last = grouped[grouped.length - 1];
    if ((last && last !== current && current.length) || (!last && current.length)) {
        grouped.push(current);
    }
    return grouped;
}
exports.groupValues = groupValues;
function validateAllowedNodesUntil(node, i, untilType = 'div', allowed = ['comment']) {
    i = 1;
    let current = node.nodes[i];
    while (current && current.type !== untilType) {
        if (!allowed.includes(current.type)) {
            return false;
        }
        i++;
        current = node.nodes[i];
    }
    return true;
}
exports.validateAllowedNodesUntil = validateAllowedNodesUntil;
exports.strategies = {
    named: (node, reportWarning) => {
        const named = {};
        getNamedArgs(node).forEach((mixinArgsGroup) => {
            const argsDivider = mixinArgsGroup[1];
            if (mixinArgsGroup.length < 3 || (argsDivider && argsDivider.type !== 'space')) {
                if (reportWarning) {
                    const argValue = mixinArgsGroup[0];
                    reportWarning(exports.valueDiagnostics.INVALID_NAMED_PARAMS(), {
                        word: argValue.value,
                    });
                }
                return;
            }
            named[mixinArgsGroup[0].value] = stringifyParam(mixinArgsGroup.slice(2));
        });
        return named;
    },
    args: (node, reportWarning) => {
        return getFormatterArgs(node, true, reportWarning).map((value) => ({ value }));
    },
};
function stringifyParam(nodes) {
    return postcss_value_parser_1.default.stringify(nodes, (n) => {
        if (n.type === 'function') {
            return postcss_value_parser_1.default.stringify(n);
        }
        else if (n.type === 'div') {
            return null;
        }
        else if (n.type === 'string') {
            return n.value;
        }
        else {
            return undefined;
        }
    });
}
//# sourceMappingURL=value.js.map