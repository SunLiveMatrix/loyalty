import * as postcss from 'postcss';
import type { FileProcessor } from './cached-process-file';
import { Diagnostics } from './diagnostics';
import { SelectorNode, Selector, SelectorList, CompoundSelector, ImmutableSelectorNode } from '@tokey/css-selector-parser';
import { ClassSymbol, ElementSymbol, STStructure } from './features';
import type { StylableMeta } from './stylable-meta';
import { CSSResolve, StylableResolverCache, StylableResolver, createSymbolResolverWithCache } from './stylable-resolver';
import type { ModuleResolver } from './types';
import type { MappedStates } from './helpers/custom-state';
export interface ResolvedElement {
    name: string;
    type: string;
    resolved: Array<CSSResolve<ClassSymbol | ElementSymbol>>;
}
export type RuntimeStVar = string | {
    [key: string]: RuntimeStVar;
} | RuntimeStVar[];
export interface StylableExports {
    classes: Record<string, string>;
    vars: Record<string, string>;
    stVars: Record<string, RuntimeStVar>;
    keyframes: Record<string, string>;
    layers: Record<string, string>;
    containers: Record<string, string>;
}
export interface StylableResults {
    meta: StylableMeta;
    exports: StylableExports;
}
export type replaceValueHook = (value: string, name: string | {
    name: string;
    args: string[];
}, isLocal: boolean, passedThrough: string[]) => string;
export type postProcessor<T = {}> = (stylableResults: StylableResults, transformer: StylableTransformer) => StylableResults & T;
export interface TransformHooks {
    postProcessor?: postProcessor;
    replaceValueHook?: replaceValueHook;
}
type EnvMode = 'production' | 'development';
export interface TransformerOptions {
    fileProcessor: FileProcessor<StylableMeta>;
    moduleResolver: ModuleResolver;
    requireModule: (modulePath: string) => any;
    diagnostics: Diagnostics;
    keepValues?: boolean;
    replaceValueHook?: replaceValueHook;
    postProcessor?: postProcessor;
    mode?: EnvMode;
    resolverCache?: StylableResolverCache;
    stVarOverride?: Record<string, string>;
    experimentalSelectorInference?: boolean;
}
export declare const transformerDiagnostics: {
    UNKNOWN_PSEUDO_ELEMENT: {
        (name: string): import("./diagnostics").DiagnosticBase;
        code: string;
        severity: import("./diagnostics").DiagnosticSeverity;
    };
};
type PostcssContainer = postcss.Container<postcss.ChildNode> | postcss.Document;
export declare class StylableTransformer {
    fileProcessor: FileProcessor<StylableMeta>;
    diagnostics: Diagnostics;
    resolver: StylableResolver;
    keepValues: boolean;
    replaceValueHook: replaceValueHook | undefined;
    postProcessor: postProcessor | undefined;
    mode: EnvMode;
    private defaultStVarOverride;
    private evaluator;
    getResolvedSymbols: ReturnType<typeof createSymbolResolverWithCache>;
    private directiveNodes;
    experimentalSelectorInference: boolean;
    containerInferredSelectorMap: Map<PostcssContainer, InferredSelector>;
    constructor(options: TransformerOptions);
    transform(meta: StylableMeta): StylableResults;
    transformAst(ast: postcss.Root, meta: StylableMeta, metaExports?: StylableExports, stVarOverride?: Record<string, string>, path?: string[], mixinTransform?: boolean, inferredSelectorMixin?: InferredSelector): void;
    resolveSelectorElements(meta: StylableMeta, selector: string): ResolvedElement[][];
    scopeSelector(originMeta: StylableMeta, selector: string, selectorNode?: postcss.Rule | postcss.AtRule, inferredNestSelector?: InferredSelector, inferredMixinSelector?: InferredSelector, unwrapGlobals?: boolean): {
        selector: string;
        elements: ResolvedElement[][];
        targetSelectorAst: SelectorList;
        inferredSelector: InferredSelector;
    };
    createSelectorContext(meta: StylableMeta, selectorAst: SelectorList, selectorNode: postcss.Rule | postcss.AtRule, selectorStr?: string, selectorNest?: InferredSelector, selectorMixin?: InferredSelector): ScopeContext;
    createInferredSelector(meta: StylableMeta, { name, type }: {
        name: string;
        type: 'class' | 'element';
    }): InferredSelector;
    scopeSelectorAst(context: ScopeContext): SelectorList;
    private handleCompoundNode;
}
type SelectorSymbol = ClassSymbol | ElementSymbol | STStructure.PartSymbol;
type InferredResolve = CSSResolve<SelectorSymbol>;
type InferredPseudoElement = {
    inferred: InferredSelector;
    selectors: SelectorList;
};
type InferredPseudoClass = {
    meta: StylableMeta;
    state: MappedStates[string];
};
export declare class InferredSelector {
    private api;
    protected resolveSet: Set<InferredResolve[]>;
    constructor(api: Pick<StylableTransformer, 'getResolvedSymbols' | 'createSelectorContext' | 'scopeSelectorAst' | 'createInferredSelector'>, resolve?: InferredResolve[] | InferredSelector);
    isEmpty(): boolean;
    set(resolve: InferredResolve[] | InferredSelector): void;
    clone(): InferredSelector;
    /**
     * Adds to the set of inferred resolved CSS
     * Assumes passes CSSResolved from the same meta/symbol are
     * the same from the same cached transform process to dedupe them.
     */
    add(resolve: InferredResolve[] | InferredSelector): void;
    /**
     * Takes a CSS part resolve and use it extend the current set of inferred resolved.
     * Used to expand the resolved mapped selector with the part definition
     * e.g. part can add nested states/parts that override the inferred mapped selector.
     */
    private addPartOverride;
    getPseudoClasses({ name: searchedName }?: {
        name?: string;
    }): Record<string, InferredPseudoClass>;
    getPseudoElements({ isFirstInSelector, experimentalSelectorInference, name, }: {
        isFirstInSelector: boolean;
        experimentalSelectorInference: boolean;
        name?: string;
    }): Record<string, InferredPseudoElement>;
    private matchedElement;
    getSingleResolve(): InferredResolve[];
}
declare class SelectorMultiplier {
    private dupIndicesPerSelector;
    addSplitPoint(selectorIndex: number, nodeIndex: number, selectors: SelectorList): void;
    duplicateSelectors(targetSelectors: SelectorList): void;
}
export declare class ScopeContext {
    originMeta: StylableMeta;
    resolver: StylableResolver;
    selectorAst: SelectorList;
    ruleOrAtRule: postcss.Rule | postcss.AtRule;
    scopeSelectorAst: StylableTransformer['scopeSelectorAst'];
    private transformer;
    inferredSelectorMixin?: InferredSelector | undefined;
    transform: boolean;
    selectorStr: string;
    selectorIndex: number;
    elements: any[];
    selectorAstResolveMap: Map<ImmutableSelectorNode, InferredSelector>;
    selector?: Selector;
    compoundSelector?: CompoundSelector;
    node?: CompoundSelector['nodes'][number];
    isNested: boolean;
    splitSelectors: SelectorMultiplier;
    lastInferredSelectorNode: SelectorNode | undefined;
    isStandaloneSelector: boolean;
    inferredSelectorStart: InferredSelector;
    inferredSelectorContext: InferredSelector;
    inferredSelectorNest: InferredSelector;
    inferredSelector: InferredSelector;
    inferredMultipleSelectors: InferredSelector;
    constructor(originMeta: StylableMeta, resolver: StylableResolver, selectorAst: SelectorList, ruleOrAtRule: postcss.Rule | postcss.AtRule, scopeSelectorAst: StylableTransformer['scopeSelectorAst'], transformer: StylableTransformer, inferredSelectorNest?: InferredSelector, inferredSelectorMixin?: InferredSelector | undefined, inferredSelectorContext?: InferredSelector, selectorStr?: string);
    get experimentalSelectorInference(): boolean;
    static legacyElementsTypesMapping: Record<string, string>;
    setNextSelectorScope(resolved: InferredResolve[] | InferredSelector, node: SelectorNode, name?: string): void;
    isFirstInSelector(node: SelectorNode): boolean;
    createNestedContext(selectorAst: SelectorList, selectorContext?: InferredSelector): ScopeContext;
    transformIntoMultiSelector(node: SelectorNode, selectors: SelectorList): void;
    isDuplicateStScopeDiagnostic(): boolean;
}
export {};
//# sourceMappingURL=stylable-transformer.d.ts.map