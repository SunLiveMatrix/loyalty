import type { CacheItem, FileProcessor, MinimalFS } from './cached-process-file';
import { Diagnostics } from './diagnostics';
import { CssParser } from './parser';
import { processNamespace, StylableProcessor } from './stylable-processor';
import type { StylableMeta } from './stylable-meta';
import { StylableResolverCache, StylableResolver, CachedModuleEntity } from './stylable-resolver';
import { ResolvedElement, StylableResults, TransformerOptions, TransformHooks } from './stylable-transformer';
import type { IStylableOptimizer, ModuleResolver } from './types';
import { STImport, STScope, STVar, STMixin, CSSClass } from './features';
import { Dependency } from './visit-meta-css-dependencies';
import { type FeatureFlags } from './features/feature';
export interface StylableConfig {
    projectRoot: string;
    fileSystem: MinimalFS;
    requireModule?: (path: string) => any;
    onProcess?: (meta: StylableMeta, path: string) => StylableMeta;
    hooks?: TransformHooks;
    resolveOptions?: {
        alias?: any;
        symlinks?: boolean;
        [key: string]: any;
    };
    optimizer?: IStylableOptimizer;
    mode?: 'production' | 'development';
    resolveNamespace?: typeof processNamespace;
    resolveModule?: ModuleResolver;
    cssParser?: CssParser;
    resolverCache?: StylableResolverCache;
    fileProcessorCache?: Record<string, CacheItem<StylableMeta>>;
    experimentalSelectorInference?: boolean;
    flags?: Partial<FeatureFlags>;
}
export declare function validateDefaultConfig(defaultConfigObj: any): void;
interface InitCacheParams {
    filter?(key: string, entity: CachedModuleEntity): boolean;
}
export type CreateProcessorOptions = Pick<StylableConfig, 'resolveNamespace'>;
export declare class Stylable {
    fileProcessor: FileProcessor<StylableMeta>;
    resolver: StylableResolver;
    stModule: STImport.StylablePublicApi;
    stScope: STScope.StylablePublicApi;
    stVar: STVar.StylablePublicApi;
    stMixin: STMixin.StylablePublicApi;
    cssClass: CSSClass.StylablePublicApi;
    projectRoot: string;
    protected fileSystem: MinimalFS;
    protected requireModule: (path: string) => any;
    protected onProcess?: (meta: StylableMeta, path: string) => StylableMeta;
    protected diagnostics: Diagnostics;
    protected hooks: TransformHooks;
    protected resolveOptions: any;
    optimizer?: IStylableOptimizer;
    protected mode: 'production' | 'development';
    resolveNamespace?: typeof processNamespace;
    moduleResolver: ModuleResolver;
    protected cssParser: CssParser;
    protected resolverCache?: StylableResolverCache;
    protected fileProcessorCache?: Record<string, CacheItem<StylableMeta>>;
    private experimentalSelectorInference;
    flags: FeatureFlags;
    constructor(config: StylableConfig);
    getDependencies(meta: StylableMeta): Dependency[];
    initCache({ filter }?: InitCacheParams): void;
    createResolver({ requireModule, resolverCache, resolvePath, }?: Pick<StylableConfig, 'requireModule' | 'resolverCache'> & {
        resolvePath?: ModuleResolver;
    }): StylableResolver;
    createProcessor({ resolveNamespace, }?: CreateProcessorOptions): StylableProcessor;
    private createTransformer;
    transform(pathOrMeta: string | StylableMeta, options?: Partial<TransformerOptions>): StylableResults;
    transformSelector(pathOrMeta: string | StylableMeta, selector: string, options?: Partial<TransformerOptions>): {
        selector: string;
        resolved: ResolvedElement[][];
    };
    transformCustomProperty(pathOrMeta: string | StylableMeta, prop: string): string;
    transformDecl(pathOrMeta: string | StylableMeta, prop: string, value: string, options?: Partial<TransformerOptions>): {
        prop: string;
        value: string;
    };
    private transformAST;
    analyze(fullPath: string, overrideSrc?: string): StylableMeta;
    resolvePath(directoryPath: string, request: string): string;
}
export {};
//# sourceMappingURL=stylable.d.ts.map