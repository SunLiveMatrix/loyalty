"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createModuleSource = exports.generateModuleSource = void 0;
/**
 * @deprecated use generateStylableJSModuleSource
 */
function generateModuleSource(stylableResult, moduleId, beforeModule, renderer, createFunction, createRenderableFunction, css, depth, exportsArgument, afterModule, renderableOnly = false) {
    const { exports, meta } = stylableResult;
    const localsExports = JSON.stringify(exports);
    const namespace = JSON.stringify(meta.namespace);
    if (renderableOnly) {
        return `${createRenderableFunction}(${css}, ${depth}, ${moduleId});`;
    }
    return `${beforeModule.join('\n')}

${exportsArgument} = ${createFunction}(
    ${namespace},
    ${localsExports},
    ${css},
    ${depth},
    ${moduleId},
    ${renderer}
);${afterModule ? '\n\n' + afterModule : ''}
`;
}
exports.generateModuleSource = generateModuleSource;
/**
 * @deprecated use generateStylableJSModuleSource
 */
function createModuleSource(stylableResult, moduleFormat = 'cjs', includeCSSInJS, moduleId = JSON.stringify(stylableResult.meta.namespace), renderableOnly = false, depth = '-1', staticRequests = [], runtimeRequest = '@stylable/runtime', afterModule = []) {
    // TODO: calc depth for node as well
    depth = typeof depth === 'number' ? depth.toString() : depth;
    if (renderableOnly && !includeCSSInJS) {
        // TODO: better error
        throw new Error('Configuration conflict (renderableOnly && !includeCSSInJS)');
    }
    const cssString = includeCSSInJS
        ? JSON.stringify(stylableResult.meta.targetAst.toString())
        : '""';
    switch (moduleFormat) {
        case 'esm': {
            const importKey = renderableOnly ? 'createRenderable' : 'create';
            return generateModuleSource(stylableResult, moduleId, [
                ...staticRequests.map((request) => `import ${JSON.stringify(request)};`),
                `import { $, ${importKey} } from ${JSON.stringify(runtimeRequest)};`,
            ], `$`, `create`, `createRenderable`, cssString, depth, 'const { classes, keyframes, vars, stVars, cssStates, style, st, $depth, $id, $css }', // = $
            [
                `export { classes, keyframes, vars, stVars, cssStates, style, st, $depth, $id, $css };`,
                ...afterModule,
            ].join('\n'), renderableOnly);
        }
        case 'cjs':
            return generateModuleSource(stylableResult, moduleId, [
                ...staticRequests.map((request) => `require(${JSON.stringify(request)});`),
                `const runtime = require(${JSON.stringify(runtimeRequest)});`,
            ], `runtime.$`, `runtime.create`, `runtime.createRenderable`, cssString, depth, 'module.exports', afterModule.join('\n'), renderableOnly);
    }
    throw new Error('Unknown module format ' + moduleFormat);
}
exports.createModuleSource = createModuleSource;
//# sourceMappingURL=module-source.js.map