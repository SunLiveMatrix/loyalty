"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getImports = exports.normalizeRelative = exports.getReplacementToken = void 0;
const build_tools_1 = require("@stylable/build-tools");
const plugin_utils_1 = require("./plugin-utils");
const path_1 = require("path");
function getReplacementToken(token) {
    return `/* INJECT */ {__${token}__:true}`;
}
exports.getReplacementToken = getReplacementToken;
function normalizeRelative(p) {
    p = p.replace(/\\/g, '/');
    return p.startsWith('.') ? p : './' + p;
}
exports.normalizeRelative = normalizeRelative;
function getImports(stylable, meta, projectRoot, assetFilter, assetsMode, includeGlobalSideEffects) {
    const urls = (0, build_tools_1.processUrlDependencies)({
        meta,
        rootContext: projectRoot,
        filter: assetFilter,
        host: {
            isAbsolute: path_1.isAbsolute,
            join: path_1.join,
        },
    });
    const imports = [];
    const unusedImports = [];
    if (includeGlobalSideEffects) {
        // new mode that collect deep side effects
        (0, build_tools_1.collectImportsWithSideEffects)(stylable, meta, (contextMeta, absPath, isUsed) => {
            if (isUsed) {
                if (!absPath.endsWith('.st.css')) {
                    imports.push(`import ${JSON.stringify(`!!${plugin_utils_1.LOADER_NAME}!` + absPath)};`);
                }
                else {
                    imports.push(`import ${JSON.stringify(absPath)};`);
                }
            }
            else if (contextMeta === meta) {
                unusedImports.push(absPath);
            }
        });
    }
    else {
        // legacy mode - only shallow imported side-effects
        for (const imported of meta.getImportStatements()) {
            // attempt to resolve the request through stylable resolveModule,
            // is case of an error fall back to the original request
            let resolved = imported.request;
            try {
                resolved = stylable.resolver.resolvePath(imported.context, imported.request);
            }
            catch (e) {
                // fallback to request
            }
            if (resolved.endsWith('.css')) {
                // We want to include Stylable and native css files that have effects on other files as regular imports
                // and other ones as unused for depth calculation
                if (!resolved.endsWith('.st.css')) {
                    imports.push(`import ${JSON.stringify(`!!${plugin_utils_1.LOADER_NAME}!` + resolved)};`);
                    continue;
                }
                if ((0, build_tools_1.hasImportedSideEffects)(stylable, meta, imported)) {
                    imports.push(`import ${JSON.stringify(resolved)};`);
                }
                else {
                    unusedImports.push(resolved);
                }
            }
        }
    }
    /**
     * Get the transformed css depth
     */
    const cssDepth = meta.transformCssDepth?.cssDepth ?? 0;
    /**
     * Take all deep dependencies since they can affect the output
     */
    const buildDependencies = Array.from(meta.transformCssDepth?.deepDependencies ?? []);
    /**
     * @remove
     * This part supports old loaders and should be removed
     */
    if (assetsMode === 'loader') {
        urls.forEach((assetPath) => imports.push(`import ${JSON.stringify(assetPath)};`));
    }
    return { urls, imports, buildDependencies, unusedImports, cssDepth };
}
exports.getImports = getImports;
//# sourceMappingURL=loader-utils.js.map