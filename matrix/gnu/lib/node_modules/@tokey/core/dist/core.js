"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.tokenize = void 0;
function tokenize(source, { shouldClose, isDelimiter, isStringDelimiter, isWhitespace, shouldAddToken, createToken, getCommentStartType, isCommentEnd, getUnclosedComment, offset = 0, }) {
    const tokens = [];
    let previousChar = '';
    let buffer = '';
    let inComment = '';
    let inString = '';
    let start = offset;
    let nextCharIndex = 0;
    for (const ch of source) {
        nextCharIndex += ch.length;
        if (inString) {
            buffer += ch;
            if (ch === inString && previousChar !== '\\') {
                pushBuffer('string');
                inString = '';
            }
        }
        else if (inComment) {
            buffer += ch;
            if (isCommentEnd(inComment, ch, source, nextCharIndex, previousChar)) {
                pushBuffer(inComment);
                inComment = '';
            }
        }
        else if ((inComment = getCommentStartType(ch, source, nextCharIndex))) {
            pushBuffer();
            buffer += ch;
        }
        else if (isStringDelimiter(ch, previousChar)) {
            pushBuffer();
            buffer += ch;
            inString = ch;
        }
        else if (isDelimiter(ch, previousChar)) {
            pushBuffer();
            buffer += ch;
            pushBuffer(ch);
        }
        else if (isWhitespace(ch) && !isWhitespace(previousChar)) {
            pushBuffer();
            buffer += ch;
        }
        else if (!isWhitespace(ch) && isWhitespace(previousChar)) {
            pushBuffer();
            buffer += ch;
        }
        else if (shouldClose?.(ch, previousChar)) {
            pushBuffer();
            buffer += ch;
            pushBuffer(ch);
        }
        else {
            buffer += ch;
        }
        previousChar = ch;
    }
    if (buffer.length) {
        if (inComment) {
            pushBuffer(getUnclosedComment(inComment));
        }
        else if (inString) {
            pushBuffer('unclosed-string');
        }
        else {
            pushBuffer();
        }
    }
    function pushBuffer(type) {
        if (buffer.length === 0) {
            return;
        }
        const end = start + buffer.length;
        type = type ?? (buffer.trim().length ? 'text' : 'space');
        if (shouldAddToken(type, buffer)) {
            tokens[tokens.length] = createToken(buffer, type, start, end);
        }
        start = end;
        buffer = '';
    }
    return tokens;
}
exports.tokenize = tokenize;
//# sourceMappingURL=core.js.map