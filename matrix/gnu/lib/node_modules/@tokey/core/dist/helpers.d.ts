import type { Token } from './types';
/**
 * Checks if a token type is comment
 */
export declare function isComment(type: string): boolean;
/**
 * Checks if a token type is string
 */
export declare function isString(type: string): boolean;
/**
 * Checks for a set of JS strings
 */
export declare const isStringDelimiter: (char: string) => boolean;
/**
 * Checks for a set of Whitespace
 */
export declare const isWhitespace: (char: string) => boolean;
/**
 * Creates a basic token
 */
export declare const createToken: <Type extends string>(value: string, type: Type, start: number, end: number) => {
    value: string;
    type: Type;
    start: number;
    end: number;
};
/**
 * Get JS type of comments for a specific set of start chars when no comment is detected empty string is used
 */
export declare function getJSCommentStartType(ch: string, source: string, nextCharIndex: number): '' | 'line-comment' | 'multi-comment';
/**
 * Get CSS type of comments for a specific set of start chars when no comment is detected empty string is used
 */
export declare function getMultilineCommentStartType(ch: string, source: string, nextCharIndex: number): '' | 'multi-comment';
/**
 * Given a JS comment type determine if this is the end of the comment
 */
export declare function isCommentEnd(commentType: string, ch: string, _source: string, _nextCharIndex: number, previousChar: string): boolean;
/**
 * Get the type of unclosed comment
 */
export declare function getUnclosedComment(commentType: string): 'line-comment' | 'unclosed-comment';
/**
 * Get the text between two token indexes
 * if source is provided it will slice the text from original source
 * otherwise the value of the tokens will be concatenated
 */
export declare function getText(tokens: Token<any>[], startIndex?: number, upToIndex?: number, source?: string): string;
/**
 * Takes an array of tokens and group them into a single token.
 * If source is provided the value will contain the text between the tokens,
 * instead of the tokens concatenated text.
 */
export declare function groupTokens<Tokens extends Token<any>[], T extends string = 'tokens'>(tokens: Tokens, type?: T, source?: string): {
    type: T;
    start: number;
    end: number;
    value: string;
    tokens: Tokens;
};
/**
 * Trim tokens from both ends with a matcher function
 */
export declare function trimTokens<Tokens extends Token<any>[]>(tokens: Tokens, shouldTrimToken: (token: Token<any>) => boolean): Token<any>[];
/**
 * get last item in array
 */
export declare function last<T>(arr: T[]): T | undefined;
//# sourceMappingURL=helpers.d.ts.map