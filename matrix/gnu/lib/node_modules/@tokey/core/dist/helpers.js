"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.last = exports.trimTokens = exports.groupTokens = exports.getText = exports.getUnclosedComment = exports.isCommentEnd = exports.getMultilineCommentStartType = exports.getJSCommentStartType = exports.createToken = exports.isWhitespace = exports.isStringDelimiter = exports.isString = exports.isComment = void 0;
/**
 * Checks if a token type is comment
 */
function isComment(type) {
    return type === 'line-comment' || type === 'multi-comment' || type === 'unclosed-comment';
}
exports.isComment = isComment;
/**
 * Checks if a token type is string
 */
function isString(type) {
    return type === 'string' || type === 'unclosed-string';
}
exports.isString = isString;
/**
 * Checks for a set of JS strings
 */
const isStringDelimiter = (char) => char === `'` || char === `"` || char === '`';
exports.isStringDelimiter = isStringDelimiter;
/**
 * Checks for a set of Whitespace
 */
const isWhitespace = (char) => char === ' ' || char === `\t` || char === `\r` || char === '\n';
exports.isWhitespace = isWhitespace;
/**
 * Creates a basic token
 */
const createToken = (value, type, start, end) => {
    return {
        value,
        type,
        start,
        end,
    };
};
exports.createToken = createToken;
/**
 * Get JS type of comments for a specific set of start chars when no comment is detected empty string is used
 */
function getJSCommentStartType(ch, source, nextCharIndex) {
    if (ch === '/' && source[nextCharIndex] === '/') {
        return 'line-comment';
    }
    else {
        return ch === '/' && source[nextCharIndex] === '*' ? 'multi-comment' : '';
    }
}
exports.getJSCommentStartType = getJSCommentStartType;
/**
 * Get CSS type of comments for a specific set of start chars when no comment is detected empty string is used
 */
function getMultilineCommentStartType(ch, source, nextCharIndex) {
    return ch === '/' && source[nextCharIndex] === '*' ? 'multi-comment' : '';
}
exports.getMultilineCommentStartType = getMultilineCommentStartType;
/**
 * Given a JS comment type determine if this is the end of the comment
 */
function isCommentEnd(commentType, ch, _source, _nextCharIndex, previousChar) {
    if (commentType === 'line-comment' && ch === '\n') {
        return true;
    }
    else if (commentType === 'multi-comment' && ch === '/' && previousChar === '*') {
        return true;
    }
    return false;
}
exports.isCommentEnd = isCommentEnd;
/**
 * Get the type of unclosed comment
 */
function getUnclosedComment(commentType) {
    if (commentType === 'line-comment') {
        return commentType;
    }
    else {
        return 'unclosed-comment';
    }
}
exports.getUnclosedComment = getUnclosedComment;
/**
 * Get the text between two token indexes
 * if source is provided it will slice the text from original source
 * otherwise the value of the tokens will be concatenated
 */
function getText(tokens, startIndex = 0, upToIndex = -1, source) {
    if (tokens.length === 0) {
        return '';
    }
    if (upToIndex === -1) {
        upToIndex = tokens.length;
    }
    if (source) {
        return source.slice(tokens[startIndex].start, tokens[upToIndex - 1].end);
    }
    else {
        let res = '';
        for (let i = startIndex; i < upToIndex; i++) {
            res += tokens[i].value;
        }
        return res;
    }
}
exports.getText = getText;
/**
 * Takes an array of tokens and group them into a single token.
 * If source is provided the value will contain the text between the tokens,
 * instead of the tokens concatenated text.
 */
function groupTokens(tokens, type = 'tokens', source) {
    return {
        type,
        start: tokens[0].start,
        end: tokens[tokens.length - 1].end,
        value: getText(tokens, undefined, undefined, source),
        tokens,
    };
}
exports.groupTokens = groupTokens;
/**
 * Trim tokens from both ends with a matcher function
 */
function trimTokens(tokens, shouldTrimToken) {
    let start = 0;
    let end = tokens.length;
    for (let i = 0; i < tokens.length; i++) {
        if (shouldTrimToken(tokens[i])) {
            start = i + 1;
        }
        else {
            break;
        }
    }
    for (let i = tokens.length - 1; i > start; i--) {
        if (shouldTrimToken(tokens[i])) {
            end = i;
        }
        else {
            break;
        }
    }
    return tokens.slice(start, end);
}
exports.trimTokens = trimTokens;
/**
 * get last item in array
 */
function last(arr) {
    return arr[arr.length - 1];
}
exports.last = last;
//# sourceMappingURL=helpers.js.map