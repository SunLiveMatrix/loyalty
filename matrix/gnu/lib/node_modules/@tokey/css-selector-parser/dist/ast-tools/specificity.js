"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.compareSpecificity = exports.calcSpecificity = void 0;
const walk_1 = require("./walk");
function calcSpecificity(ast) {
    const result = [0, 0, 0, 0];
    // ToDo: remove casting once immutable walk is supported
    (0, walk_1.walk)(ast, (node) => {
        switch (node.type) {
            case `type`:
            case `pseudo_element`:
                result[3]++;
                break;
            case `class`:
            case `attribute`:
                result[2]++;
                break;
            case `pseudo_class`:
                if (customPseudoClass[node.value]) {
                    customPseudoClass[node.value](node, result);
                    return walk_1.walk.skipNested;
                }
                result[2]++;
                break;
            case `id`:
                result[1]++;
                break;
        }
        return node.type !== `selector` && node.type !== `compound_selector`
            ? walk_1.walk.skipNested
            : undefined;
    });
    return result;
}
exports.calcSpecificity = calcSpecificity;
const customPseudoClass = {
    not: mostSpecificInnerSelector,
    is: mostSpecificInnerSelector,
    has: mostSpecificInnerSelector,
    where: () => {
        /* no specificity*/
    },
    'nth-child': pseudoClassPlusMostSpecificInnerSelector,
    'nth-last-child': pseudoClassPlusMostSpecificInnerSelector,
    'nth-of-type': pseudoClassPlusMostSpecificInnerSelector,
    'nth-last-of-type': pseudoClassPlusMostSpecificInnerSelector,
};
function pseudoClassPlusMostSpecificInnerSelector(node, result) {
    result[2]++;
    mostSpecificInnerSelector(node, result);
}
function mostSpecificInnerSelector(node, result) {
    if (node.nodes?.length) {
        let highest = [0, 0, 0, 0];
        for (const selector of node.nodes) {
            const currentSpecificity = calcSpecificity(selector);
            if (!highest || compareSpecificity(currentSpecificity, highest) === 1) {
                highest = currentSpecificity;
            }
        }
        addSpecificity(result, highest);
    }
}
/**
 * compare 2 specificities
 * @param a first specificity
 * @param b second specificity
 * @returns 0 if equal, 1 when a is more specific, -1 when b is more specific
 */
function compareSpecificity(a, b) {
    for (let i = 0; i < 4; ++i) {
        const specificityDiff = a[i] - b[i];
        if (specificityDiff > 0) {
            return 1;
        }
        else if (specificityDiff < 0) {
            return -1;
        }
    }
    return 0;
}
exports.compareSpecificity = compareSpecificity;
/**
 * mutate the first value, adding the second one
 * @param to specificity reference to to
 * @param from specificity amount to add
 */
function addSpecificity(to, from) {
    for (let i = 0; i < 4; ++i) {
        to[i] += from[i];
    }
}
//# sourceMappingURL=specificity.js.map