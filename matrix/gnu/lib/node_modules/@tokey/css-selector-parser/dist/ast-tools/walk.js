"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.walk = void 0;
const nestEnd = Symbol(`nest-end`);
function walk(topNode, visit, options = {}) {
    // set initial top nodes to traverse
    const toVisit = Array.isArray(topNode)
        ? [...topNode]
        : [topNode];
    // initiate context
    const context = createWalkContext(topNode);
    // iterate nodes
    while (toVisit.length) {
        const current = toVisit.shift();
        if (current === nestEnd) {
            // end of nested level
            context.up();
            continue;
        }
        else if ((!options.ignoreList || !options.ignoreList.includes(current.type)) &&
            (!options.visitList || options.visitList.includes(current.type))) {
            // visit node
            let skipAmount = visit(current, context.indexInSelector, context.nodesInSelector, context.parents) ?? -1;
            // point to next selector node
            context.next();
            // check if to skip nested or current/following selectors
            if (skipAmount === Infinity) {
                // stop all: fast bail out
                return;
            }
            else if (skipAmount >= 0) {
                // skip levels
                while (skipAmount > 0 && toVisit.length) {
                    const next = toVisit.shift();
                    if (next === nestEnd) {
                        skipAmount--;
                        context.up();
                    }
                }
                continue;
            }
        }
        else {
            // point to next selector node
            context.next();
        }
        // add nested nodes
        if (isWithNodes(current)) {
            context.insertNested(current);
            toVisit.unshift(...current.nodes, nestEnd);
        }
    }
}
exports.walk = walk;
function createWalkContext(topNode) {
    const prevIndex = [];
    const prevParents = [[]];
    const context = {
        parents: [],
        indexInSelector: 0,
        nodesInSelector: Array.isArray(topNode)
            ? topNode
            : `nodes` in topNode
                ? topNode.nodes
                : [topNode],
        up() {
            context.parents.pop();
            context.indexInSelector = prevIndex.shift();
            const currentParents = context.parents;
            const currentParent = currentParents[currentParents.length - 1];
            context.nodesInSelector = currentParent ? currentParent.nodes : topNode;
        },
        next() {
            context.indexInSelector++;
        },
        insertNested(node) {
            context.parents = [...context.parents, node];
            prevParents.push(context.parents);
            prevIndex.unshift(context.indexInSelector);
            context.indexInSelector = 0;
            context.nodesInSelector = node.nodes;
        },
    };
    return context;
}
walk.skipNested = 0;
walk.skipCurrentSelector = 1;
walk.stopAll = Infinity;
function isWithNodes(node) {
    return node && `nodes` in node;
}
//# sourceMappingURL=walk.js.map