"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deepFindFilesSync = exports.extractPackageLocations = exports.resolveWorkspacePackages = void 0;
const minimatch_1 = require("minimatch");
const language_helpers_1 = require("./language-helpers");
const npm_package_1 = require("./npm-package");
function resolveWorkspacePackages(basePath, workspaces, host) {
    const packages = new Map();
    const packageJsonFilePaths = Array.from(deepFindFilesSync(basePath, (fileName) => fileName === npm_package_1.PACKAGE_JSON, (directoryName) => !directoryName.startsWith('.') && directoryName !== 'node_modules', host));
    for (const packageDirGlob of workspaces) {
        const packageJsonGlob = ensureEndsWithPackageJson(packageDirGlob);
        const packageJsonPaths = packageJsonFilePaths.filter((packageJsonPath) => (0, minimatch_1.minimatch)(host.relative(basePath, packageJsonPath), packageJsonGlob));
        for (const packageJsonPath of packageJsonPaths) {
            if (packages.has(packageJsonPath)) {
                continue;
            }
            const packageJsonContent = host.readFileSync(packageJsonPath, 'utf8');
            const packageJson = JSON.parse(packageJsonContent);
            if (!(0, language_helpers_1.isPlainObject)(packageJson)) {
                throw new Error(`${packageJsonPath}: no valid json object.`);
            }
            const displayName = packageJson.name ? packageJson.name : packageJsonPath;
            packages.set(packageJsonPath, {
                displayName,
                packageJsonPath,
                packageJson,
                directoryPath: host.dirname(packageJsonPath),
                packageJsonContent,
            });
        }
    }
    return Array.from(packages.values());
}
exports.resolveWorkspacePackages = resolveWorkspacePackages;
function extractPackageLocations(workspaces) {
    if ((0, language_helpers_1.isString)(workspaces)) {
        return [workspaces];
    }
    else if (Array.isArray(workspaces)) {
        if (workspaces.every(language_helpers_1.isString)) {
            return workspaces;
        }
    }
    else if ((0, language_helpers_1.isPlainObject)(workspaces)) {
        const { packages } = workspaces;
        if ((0, language_helpers_1.isString)(packages)) {
            return [packages];
        }
        else if (Array.isArray(packages) && packages.every(language_helpers_1.isString)) {
            return packages;
        }
    }
    throw new Error(`cannot extract package locations from "workspaces" field.`);
}
exports.extractPackageLocations = extractPackageLocations;
function* deepFindFilesSync(directoryPath, filterFile = () => true, filterDirectory = () => true, host) {
    for (const item of host.readdirSync(directoryPath, { withFileTypes: true })) {
        const itemPath = host.join(directoryPath, item.name);
        if (item.isFile() && filterFile(item.name, itemPath)) {
            yield host.join(directoryPath, item.name);
        }
        else if (item.isDirectory() && filterDirectory(item.name, itemPath)) {
            yield* deepFindFilesSync(itemPath, filterFile, filterDirectory, host);
        }
    }
}
exports.deepFindFilesSync = deepFindFilesSync;
function ensureEndsWithPackageJson(workspace) {
    if (workspace.endsWith(`/${npm_package_1.PACKAGE_JSON}`)) {
        return workspace;
    }
    else if (workspace.endsWith('/')) {
        return workspace + npm_package_1.PACKAGE_JSON;
    }
    else {
        return `${workspace}/${npm_package_1.PACKAGE_JSON}`;
    }
}
//# sourceMappingURL=workspaces.js.map