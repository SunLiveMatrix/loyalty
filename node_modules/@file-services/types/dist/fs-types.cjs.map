{
  "version": 3,
  "sources": ["../src/index.ts", "../src/common-fs-types.ts"],
  "sourcesContent": ["export * from './base-api';\nexport * from './common-fs-types';\nexport * from './extended-api';\nexport * from './path';\nexport * from './watch-api';\n", "export type BufferEncoding =\n  | 'ascii'\n  | 'utf8'\n  | 'utf-8'\n  | 'utf16le'\n  | 'ucs2'\n  | 'ucs-2'\n  | 'base64'\n  | 'latin1'\n  | 'binary'\n  | 'hex';\n\n// use global augmentation so that users without @types/node will have a partial Buffer interface\ndeclare global {\n  interface Buffer {\n    toString(ecoding?: BufferEncoding): string;\n  }\n}\n\nexport type CallbackFn<T> = (error: Error | null, value: T) => void;\nexport type CallbackFnVoid = (error?: Error | null) => void;\n\nexport interface StatSyncOptions {\n  /**\n   * Whether an exception will be thrown if no file system entry exists, rather than returning `undefined`.\n   * @default true\n   */\n  throwIfNoEntry?: boolean;\n}\n\nexport type WriteFileOptions =\n  | {\n      encoding?: BufferEncoding | null;\n      mode?: number | string;\n      flag?: string;\n    }\n  | BufferEncoding\n  | null;\n\nexport type ReadFileOptions =\n  | {\n      encoding?: BufferEncoding | null;\n      flag?: string;\n    }\n  | BufferEncoding\n  | null;\n\nexport enum FileSystemConstants {\n  /**\n   * When passed as a flag to `copyFile` or `copyFileSync`,\n   * causes operation to fail if destination already exists.\n   */\n  COPYFILE_EXCL = 1,\n}\n\nexport interface IDirectoryContents {\n  [nodeName: string]: string | IDirectoryContents;\n}\n\n/**\n * Subset of the original `fs.Dirent` class.\n */\nexport interface IDirectoryEntry {\n  /**\n   * Base name of the entry.\n   *\n   * @example `package.json`\n   */\n  name: string;\n\n  /**\n   * Whether the entry points to a file.\n   */\n  isFile(): boolean;\n\n  /**\n   * Whether the entry points to a directory.\n   */\n  isDirectory(): boolean;\n\n  /**\n   * Whether the entry is a symbolic link.\n   */\n  isSymbolicLink(): boolean;\n}\n\n/**\n * Subset of the original `fs.Stats` interface\n */\nexport interface IFileSystemStats {\n  /**\n   * Creation time\n   */\n  birthtime: Date;\n\n  /**\n   * Modification time\n   */\n  mtime: Date;\n\n  /**\n   * is the path pointing to a file\n   */\n  isFile(): boolean;\n\n  /**\n   * is the path pointing to a directory\n   */\n  isDirectory(): boolean;\n\n  /**\n   * is the path pointing to a symbolic link\n   */\n  isSymbolicLink(): boolean;\n}\n\n/**\n * Descriptor object for an existing file system path.\n */\nexport interface IFileSystemDescriptor {\n  /**\n   * Base name of the file system node.\n   *\n   * @example 'package.json'\n   */\n  name: string;\n\n  /**\n   * Absolute path to the file system node.\n   *\n   * @example '/path/to/package.json'\n   */\n  path: string;\n}\n\nexport interface IWalkOptions {\n  /**\n   * Optional file filtering function that receives a file descriptor and returns\n   * whether it should be included in the result.\n   *\n   * @default true returned for all files.\n   */\n  filterFile?(pathDesc: IFileSystemDescriptor): boolean;\n\n  /**\n   * Optional directory filtering function that receives a directory descriptor and returns\n   * whether it should be walked into.\n   *\n   * @default true returned for all directories.\n   */\n  filterDirectory?(pathDesc: IFileSystemDescriptor): boolean;\n}\n\nexport interface RmOptions {\n  /**\n   * When `true`, exceptions will be ignored if `path` does not exist.\n   * @default false\n   */\n  force?: boolean | undefined;\n\n  /**\n   * If `true`, perform a recursive directory removal.\n   * @default false\n   */\n  recursive?: boolean | undefined;\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;AC+CO,IAAK,sBAAL,kBAAKA,yBAAL;AAKL,EAAAA,0CAAA,mBAAgB,KAAhB;AALU,SAAAA;AAAA,GAAA;",
  "names": ["FileSystemConstants"]
}
