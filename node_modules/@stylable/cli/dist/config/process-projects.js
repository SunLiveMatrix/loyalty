"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.processProjects = void 0;
const resolve_options_1 = require("./resolve-options");
function processProjects({ projects, presets }, { defaultOptions = (0, resolve_options_1.createDefaultOptions)() } = {}) {
    const entities = [];
    if (!Array.isArray(projects) && typeof projects !== 'object') {
        throw new Error('Invalid projects type');
    }
    if (Array.isArray(projects)) {
        for (const entry of projects) {
            entities.push(resolveProjectEntry(typeof entry === 'string' ? [entry] : entry, defaultOptions, presets));
        }
    }
    else if (typeof projects === 'object') {
        for (const entry of Object.entries(projects)) {
            entities.push(resolveProjectEntry(entry, defaultOptions, presets));
        }
    }
    return {
        entities,
    };
}
exports.processProjects = processProjects;
function resolveProjectEntry([request, value], configOptions, availablePresets = {}) {
    const totalOptions = [];
    if (!value) {
        totalOptions.push({ ...configOptions });
    }
    else if (Array.isArray(value)) {
        for (const valueEntry of value) {
            totalOptions.push(...normalizeEntry(valueEntry));
        }
    }
    else {
        totalOptions.push(...normalizeEntry(value));
    }
    request = request.trim();
    return {
        request,
        options: totalOptions.map((options, i, { length }) => {
            const mergedOptions = (0, resolve_options_1.mergeBuildOptions)(configOptions, options);
            (0, resolve_options_1.validateOptions)(mergedOptions, length > 1 ? `[${i}] ${request}` : request);
            return mergedOptions;
        }),
    };
    function normalizeEntry(entryValue) {
        if (typeof entryValue === 'string') {
            return [resolvePreset(entryValue, availablePresets)];
        }
        else if (typeof entryValue === 'object') {
            if ('options' in entryValue) {
                const currentPresets = entryValue.presets || [];
                if (typeof entryValue.preset === 'string') {
                    currentPresets.push(entryValue.preset);
                }
                return currentPresets.map((presetName) => (0, resolve_options_1.mergeBuildOptions)(configOptions, resolvePreset(presetName, availablePresets), entryValue.options || {}));
            }
            else {
                return [entryValue];
            }
        }
        else {
            throw new Error(`Cannot resolve entry "${entryValue}"`);
        }
    }
}
function resolvePreset(presetName, availablePresets) {
    const preset = availablePresets[presetName];
    if (!preset || typeof presetName !== 'string') {
        throw new Error(`Cannot resolve preset named "${presetName}"`);
    }
    return preset;
}
//# sourceMappingURL=process-projects.js.map