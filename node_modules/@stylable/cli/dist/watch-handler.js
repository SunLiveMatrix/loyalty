"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WatchHandler = void 0;
const decache_1 = __importDefault(require("decache"));
const directory_process_service_1 = require("./directory-process-service/directory-process-service");
const logger_1 = require("./logger");
const messages_1 = require("./messages");
const diagnostics_manager_1 = require("./diagnostics-manager");
class WatchHandler {
    constructor(fileSystem, options = {}) {
        this.fileSystem = fileSystem;
        this.options = options;
        this.builds = [];
        this.generatedFiles = new Set();
        this.listener = async (event) => {
            this.log(messages_1.buildMessages.CHANGE_EVENT_TRIGGERED(event.path));
            if (this.generatedFiles.has(event.path)) {
                this.log(messages_1.buildMessages.SKIP_GENERATED_FILE(event.path));
                return;
            }
            this.invalidateCache(event.path);
            let foundChanges = false;
            const files = new Map();
            for (const { service, identifier } of this.builds) {
                for (const path of service.getAffectedFiles(event.path)) {
                    if (files.has(path)) {
                        continue;
                    }
                    files.set(path, (0, directory_process_service_1.createWatchEvent)(path, this.fileSystem));
                }
                const { hasChanges, generatedFiles } = await service.handleWatchChange(files, event);
                if (hasChanges) {
                    if (!foundChanges) {
                        foundChanges = true;
                        this.generatedFiles.clear();
                        this.log(logger_1.levels.clear);
                        this.log(messages_1.buildMessages.CHANGE_DETECTED(event.path), logger_1.levels.info);
                    }
                    for (const generatedFile of generatedFiles) {
                        this.generatedFiles.add(generatedFile);
                        files.set(generatedFile, {
                            ...(files.get(generatedFile) ||
                                (0, directory_process_service_1.createWatchEvent)(generatedFile, this.fileSystem)),
                            generated: true,
                        });
                    }
                    this.log(messages_1.buildMessages.BUILD_PROCESS_INFO(identifier), Array.from(files.keys()));
                }
            }
            if (foundChanges) {
                const { changed, deleted } = filesStats(files);
                this.log(messages_1.buildMessages.WATCH_SUMMARY(changed, deleted), logger_1.levels.info);
                const reported = this.diagnosticsManager.report();
                if (!reported) {
                    this.log(messages_1.buildMessages.NO_DIAGNOSTICS(), messages_1.buildMessages.CONTINUE_WATCH(), logger_1.levels.info);
                }
                else {
                    this.log(messages_1.buildMessages.CONTINUE_WATCH(), logger_1.levels.info);
                }
            }
        };
        this.resolverCache = this.options.resolverCache ?? new Map();
        this.log = this.options.log ?? (0, logger_1.createDefaultLogger)();
        this.diagnosticsManager =
            this.options.diagnosticsManager ?? new diagnostics_manager_1.DiagnosticsManager({ log: this.log });
    }
    register({ generatedFiles, ...build }) {
        this.builds.push(build);
        for (const file of generatedFiles) {
            this.generatedFiles.add(file);
        }
    }
    start() {
        this.log(messages_1.buildMessages.START_WATCHING(), logger_1.levels.info);
        this.fileSystem.watchService.addGlobalListener(this.listener);
    }
    async stop() {
        this.log(messages_1.buildMessages.STOP_WATCHING(), logger_1.levels.info);
        this.diagnosticsManager.clear();
        this.fileSystem.watchService.removeGlobalListener(this.listener);
        for (const { service } of this.builds) {
            await service.dispose();
        }
        this.builds = [];
    }
    invalidateCache(filePath) {
        for (const [key, entity] of this.resolverCache) {
            if (!entity.value ||
                entity.resolvedPath === filePath ||
                // deep source invalidation
                this.options.outputFiles?.get(entity.resolvedPath)?.has(filePath)) {
                if (entity.kind === 'js') {
                    (0, decache_1.default)(filePath);
                }
                this.resolverCache.delete(key);
            }
        }
    }
}
exports.WatchHandler = WatchHandler;
function filesStats(files) {
    const filesChangesSummary = {
        changed: 0,
        deleted: 0,
    };
    for (const file of files.values()) {
        if (file.generated) {
            continue;
        }
        if (file.stats) {
            filesChangesSummary.changed++;
        }
        else {
            filesChangesSummary.deleted++;
        }
    }
    return filesChangesSummary;
}
//# sourceMappingURL=watch-handler.js.map