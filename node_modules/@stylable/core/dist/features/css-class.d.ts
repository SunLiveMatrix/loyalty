import { FeatureContext, FeatureTransformContext } from './feature';
import type { StylableSymbol } from './st-symbol';
import type { ImportSymbol } from './st-import';
import type { ElementSymbol } from './css-type';
import type * as STStructure from './st-structure';
import * as STCustomState from './st-custom-state';
import type { StylableMeta } from '../stylable-meta';
import type { Stylable } from '../stylable';
import { ImmutableClass, Class, SelectorNode, ImmutableSelectorNode } from '@tokey/css-selector-parser';
import * as postcss from 'postcss';
import postcssValueParser from 'postcss-value-parser';
export interface StPartDirectives extends STStructure.HasParts, Partial<STCustomState.HasStates> {
    '-st-root'?: boolean;
    '-st-extends'?: ImportSymbol | ClassSymbol | ElementSymbol;
    '-st-global'?: SelectorNode[];
}
export interface ClassSymbol extends StPartDirectives {
    _kind: 'class';
    name: string;
    alias?: ImportSymbol;
    scoped?: string;
}
export declare const diagnostics: {
    INVALID_FUNCTIONAL_SELECTOR: {
        (selector: string, type: string): import("../diagnostics").DiagnosticBase;
        code: string;
        severity: import("../diagnostics").DiagnosticSeverity;
    };
    UNSCOPED_CLASS: {
        (name: string): import("../diagnostics").DiagnosticBase;
        code: string;
        severity: import("../diagnostics").DiagnosticSeverity;
    };
    STATE_DEFINITION_IN_ELEMENT: {
        (): import("../diagnostics").DiagnosticBase;
        code: string;
        severity: import("../diagnostics").DiagnosticSeverity;
    };
    STATE_DEFINITION_IN_COMPLEX: {
        (): import("../diagnostics").DiagnosticBase;
        code: string;
        severity: import("../diagnostics").DiagnosticSeverity;
    };
    OVERRIDE_TYPED_RULE: {
        (key: string, name: string): import("../diagnostics").DiagnosticBase;
        code: string;
        severity: import("../diagnostics").DiagnosticSeverity;
    };
    CANNOT_RESOLVE_EXTEND: {
        (name: string): import("../diagnostics").DiagnosticBase;
        code: string;
        severity: import("../diagnostics").DiagnosticSeverity;
    };
    CANNOT_EXTEND_IN_COMPLEX: {
        (): import("../diagnostics").DiagnosticBase;
        code: string;
        severity: import("../diagnostics").DiagnosticSeverity;
    };
    EMPTY_ST_GLOBAL: {
        (): import("../diagnostics").DiagnosticBase;
        code: string;
        severity: import("../diagnostics").DiagnosticSeverity;
    };
    UNSUPPORTED_MULTI_SELECTORS_ST_GLOBAL: {
        (): import("../diagnostics").DiagnosticBase;
        code: string;
        severity: import("../diagnostics").DiagnosticSeverity;
    };
    IMPORT_ISNT_EXTENDABLE: {
        (): import("../diagnostics").DiagnosticBase;
        code: string;
        severity: import("../diagnostics").DiagnosticSeverity;
    };
    CANNOT_EXTEND_UNKNOWN_SYMBOL: {
        (name: string): import("../diagnostics").DiagnosticBase;
        code: string;
        severity: import("../diagnostics").DiagnosticSeverity;
    };
    CANNOT_EXTEND_JS: {
        (): import("../diagnostics").DiagnosticBase;
        code: string;
        severity: import("../diagnostics").DiagnosticSeverity;
    };
    UNKNOWN_IMPORT_ALIAS: {
        (name: string): import("../diagnostics").DiagnosticBase;
        code: string;
        severity: import("../diagnostics").DiagnosticSeverity;
    };
    DISABLED_DIRECTIVE: {
        (className: string, directive: "-st-extends" | "-st-states" | "-st-root" | "-st-global"): import("../diagnostics").DiagnosticBase;
        code: string;
        severity: import("../diagnostics").DiagnosticSeverity;
    };
};
export declare const hooks: import("./feature").FeatureHooks<{
    SELECTOR: Class;
    IMMUTABLE_SELECTOR: ImmutableClass;
    RESOLVED: Record<string, string>;
}>;
export declare class StylablePublicApi {
    private stylable;
    constructor(stylable: Stylable);
    transformIntoSelector(meta: StylableMeta, name: string): string | undefined;
}
export declare function get(meta: StylableMeta, name: string): ClassSymbol | undefined;
export declare function getAll(meta: StylableMeta): Record<string, ClassSymbol>;
export declare function createSymbol(input: Partial<ClassSymbol> & {
    name: string;
}): ClassSymbol;
export declare function addClass(context: FeatureContext, name: string, rule?: postcss.Node): ClassSymbol;
export declare function namespaceClass(meta: StylableMeta, symbol: StylableSymbol, node: SelectorNode, // ToDo: check this is the correct type, should this be inline selector?
wrapInGlobal?: boolean): void;
export declare function addDevRules({ getResolvedSymbols, meta }: FeatureTransformContext): void;
export declare function createWarningRule(extendedNode: string, scopedExtendedNode: string, extendedFile: string, extendingNode: string, scopedExtendingNode: string, extendingFile: string): postcss.Rule;
export declare function validateClassScoping({ context, classSymbol, locallyScoped, reportUnscoped, node, nodes, index, rule, }: {
    context: FeatureContext;
    classSymbol: ClassSymbol;
    locallyScoped: boolean;
    reportUnscoped: boolean;
    node: ImmutableClass;
    nodes: ImmutableSelectorNode[];
    index: number;
    rule: postcss.Rule;
}): boolean;
export declare function checkForScopedNodeAfter(context: FeatureContext, rule: postcss.Rule, nodes: ImmutableSelectorNode[], index: number): boolean;
export declare function disableDirectivesForClass(context: FeatureContext, className: string): void;
export declare function extendTypedRule(context: FeatureContext, node: postcss.Node, selector: string, key: keyof StPartDirectives, value: any): void;
export interface ArgValue {
    type: string;
    value: string;
}
export interface ExtendsValue {
    symbolName: string;
    args: ArgValue[][] | null;
}
export declare function parseStExtends(value: string): {
    ast: postcssValueParser.ParsedValue;
    types: ExtendsValue[];
};
//# sourceMappingURL=css-class.d.ts.map