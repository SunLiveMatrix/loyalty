import { FeatureContext } from './feature';
import type { ImportSymbol } from './st-import';
import type { VarSymbol } from './st-var';
import type { ClassSymbol } from './css-class';
import type { ElementSymbol } from './css-type';
import type { CSSVarSymbol } from './css-custom-property';
import type { KeyframesSymbol } from './css-keyframes';
import type { LayerSymbol } from './css-layer';
import type { ContainerSymbol } from './css-contains';
import type { StylableMeta } from '../stylable-meta';
import type * as postcss from 'postcss';
export type StylableSymbol = ImportSymbol | VarSymbol | ClassSymbol | ElementSymbol | CSSVarSymbol | KeyframesSymbol | LayerSymbol | ContainerSymbol;
declare const NAMESPACES: {
    readonly import: "main";
    readonly class: "main";
    readonly cssVar: "main";
    readonly element: "main";
    readonly keyframes: "keyframes";
    readonly layer: "layer";
    readonly container: "container";
    readonly var: "main";
};
export declare const readableTypeMap: Record<StylableSymbol['_kind'], string>;
type SymbolTypes = StylableSymbol['_kind'];
type filterSymbols<T extends SymbolTypes> = Extract<StylableSymbol, {
    _kind: T;
}>;
type SymbolMap = {
    [K in SymbolTypes]: filterSymbols<K>;
};
type SymbolTypeToNamespace = typeof NAMESPACES;
type FilterByNamespace<NS extends Namespaces, T extends SymbolTypes = SymbolTypes> = T extends any ? SymbolTypeToNamespace[T] extends NS ? T : never : never;
type NamespaceToSymbolType = {
    [NS in SymbolTypeToNamespace[SymbolTypes]]: FilterByNamespace<NS>;
};
export type Namespaces = keyof NamespaceToSymbolType;
export type SymbolByNamespace<NS extends Namespaces> = Extract<StylableSymbol, {
    _kind: NamespaceToSymbolType[NS];
}>;
interface SymbolDeclaration<NS = Namespaces> {
    name: string;
    symbol: filterSymbols<SymbolTypes extends any ? (Namespaces extends NS ? SymbolTypes : any) : any>;
    ast: postcss.Node | undefined;
    safeRedeclare: boolean;
}
interface State {
    byNS: {
        [NS in Namespaces]: SymbolDeclaration<NS>[];
    };
    byNSFlat: {
        [NS in Namespaces]: Record<string, filterSymbols<NamespaceToSymbolType[NS]>>;
    };
    byType: {
        [T in keyof SymbolMap]: Record<string, SymbolMap[T]>;
    };
}
export declare const diagnostics: {
    REDECLARE_SYMBOL: {
        (name: string): import("../diagnostics").DiagnosticBase;
        code: string;
        severity: import("../diagnostics").DiagnosticSeverity;
    };
    REDECLARE_ROOT: {
        (): import("../diagnostics").DiagnosticBase;
        code: string;
        severity: import("../diagnostics").DiagnosticSeverity;
    };
};
export declare const hooks: import("./feature").FeatureHooks<import("./feature").NodeTypes>;
export declare function get<T extends keyof SymbolMap>(meta: StylableMeta, name: string, type?: T): filterSymbols<T> | undefined;
export declare function getAll<NS extends keyof NamespaceToSymbolType = `main`>(meta: StylableMeta, ns?: NS): {
    container: Record<string, ContainerSymbol>;
    main: Record<string, filterSymbols<"element" | "var" | "class" | "import" | "cssVar">>;
    layer: Record<string, LayerSymbol>;
    keyframes: Record<string, KeyframesSymbol>;
}[NS];
export declare function getAllByType<T extends SymbolTypes>(meta: StylableMeta, type: T): State['byType'][T];
export declare function addSymbol({ context, symbol, node, safeRedeclare, localName, }: {
    context: FeatureContext;
    symbol: StylableSymbol;
    node?: postcss.Node;
    safeRedeclare?: boolean;
    localName?: string;
}): StylableSymbol | undefined;
export declare function reportRedeclare(context: FeatureContext): void;
export {};
//# sourceMappingURL=st-symbol.d.ts.map