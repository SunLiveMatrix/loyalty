import type * as postcss from 'postcss';
import { Diagnostics } from './diagnostics';
import type { StylableMeta } from './stylable-meta';
import { StylableResolver, MetaResolvedSymbols } from './stylable-resolver';
import type { replaceValueHook, RuntimeStVar, StylableTransformer } from './stylable-transformer';
import type { FeatureTransformContext } from './features/feature';
export interface EvalValueData {
    value: string;
    node?: postcss.Node;
    meta: StylableMeta;
    stVarOverride?: Record<string, string> | null;
    cssVarsMapping?: Record<string, string>;
    args?: string[];
    rootArgument?: string;
    initialNode?: postcss.Node;
}
export interface EvalValueResult {
    topLevelType: any;
    runtimeValue: RuntimeStVar;
    outputValue: string;
    typeError?: Error;
}
export declare class StylableEvaluator {
    stVarOverride: Record<string, string> | null | undefined;
    getResolvedSymbols: (meta: StylableMeta) => MetaResolvedSymbols;
    valueHook?: replaceValueHook;
    constructor(options: {
        stVarOverride?: Record<string, string> | null;
        valueHook?: replaceValueHook;
        getResolvedSymbols: (meta: StylableMeta) => MetaResolvedSymbols;
    });
    evaluateValue(context: Omit<FeatureTransformContext, 'getResolvedSymbols'>, data: Omit<EvalValueData, 'passedThrough' | 'valueHook'>): EvalValueResult;
}
export declare const functionDiagnostics: {
    FAIL_TO_EXECUTE_FORMATTER: {
        (resolvedValue: string, message: string): import("./diagnostics").DiagnosticBase;
        code: string;
        severity: import("./diagnostics").DiagnosticSeverity;
    };
    UNKNOWN_FORMATTER: {
        (name: string): import("./diagnostics").DiagnosticBase;
        code: string;
        severity: import("./diagnostics").DiagnosticSeverity;
    };
};
export declare function resolveArgumentsValue(options: Record<string, string>, transformer: StylableTransformer, meta: StylableMeta, diagnostics: Diagnostics, node: postcss.Node, variableOverride?: Record<string, string>, path?: string[], cssVarsMapping?: Record<string, string>): Record<string, string>;
export declare function processDeclarationValue(resolver: StylableResolver, getResolvedSymbols: (meta: StylableMeta) => MetaResolvedSymbols, value: string, meta: StylableMeta, node?: postcss.Node, variableOverride?: Record<string, string> | null, valueHook?: replaceValueHook, diagnostics?: Diagnostics, passedThrough?: string[], cssVarsMapping?: Record<string, string>, args?: string[], rootArgument?: string, initialNode?: postcss.Node): EvalValueResult;
export declare function evalDeclarationValue(resolver: StylableResolver, value: string, meta: StylableMeta, node?: postcss.Node, variableOverride?: Record<string, string> | null, valueHook?: replaceValueHook, diagnostics?: Diagnostics, passedThrough?: string[], cssVarsMapping?: Record<string, string>, args?: string[], getResolvedSymbols?: (meta: StylableMeta) => MetaResolvedSymbols): string;
//# sourceMappingURL=functions.d.ts.map