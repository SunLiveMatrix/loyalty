import { parseCssSelector, stringifySelectorAst, walk, SelectorNode, PseudoClass, Selector, SelectorList, FunctionalSelector, Class, Attribute, Invalid, ImmutableSelector, ImmutableSelectorList, ImmutableSelectorNode, Combinator } from '@tokey/css-selector-parser';
export declare const parseSelector: typeof parseCssSelector;
export declare const stringifySelector: typeof stringifySelectorAst;
export declare const walkSelector: typeof walk;
export declare function parseSelectorWithCache(selector: string, options: {
    clone: true;
}): SelectorList;
export declare function parseSelectorWithCache(selector: string, options?: {
    clone?: false;
}): ImmutableSelectorList;
export declare function cloneSelector<T extends ImmutableSelector | ImmutableSelectorList>(s: T): T;
/**
 * returns for each selector if it contains only
 * a single class or an element selector.
 */
export declare function isSimpleSelector(selector: string): {
    isSimple: boolean;
    type: 'class' | 'type' | 'complex';
}[];
/**
 * take an ast node with nested nodes "XXX(nest1,  nest2)"
 * and convert it to a flat selector as node: "nest1, nest2"
 */
export declare function flattenFunctionalSelector(node: FunctionalSelector): Selector;
/**
 * ast convertors
 */
export declare function convertToClass(node: SelectorNode): Class;
export declare function convertToAttribute(node: SelectorNode): Attribute;
export declare function convertToInvalid(node: SelectorNode): Invalid;
export declare function convertToSelector(node: SelectorNode): Selector;
export declare function convertToPseudoClass(node: SelectorNode, name: string, nestedSelectors?: SelectorList): PseudoClass;
export declare function createCombinatorSelector(partial: Partial<Combinator>): Combinator;
export declare function isInPseudoClassContext(parents: ReadonlyArray<ImmutableSelectorNode>): boolean;
export declare function matchTypeAndValue(a: Partial<ImmutableSelectorNode>, b: Partial<ImmutableSelectorNode>): boolean;
export declare function isCompRoot(name: string): RegExpMatchArray | null;
/**
 * combine 2 selector lists.
 * - add each scoping selector at the begging of each nested selector
 * - replace any nesting `&` nodes in the nested selector with the scoping selector nodes
 */
export declare function scopeNestedSelector(scopeSelectorAst: ImmutableSelectorList, nestedSelectorAst: ImmutableSelectorList, rootScopeLevel?: boolean, isAnchor?: (node: SelectorNode) => boolean): {
    selector: string;
    ast: SelectorList;
};
//# sourceMappingURL=selector.d.ts.map