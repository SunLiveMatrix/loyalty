import type { ParsedValue } from '../types';
import postcssValueParser from 'postcss-value-parser';
import type { Node as ValueNode } from 'postcss-value-parser';
import { DiagnosticBase } from '../diagnostics';
export type ReportWarning = (diagnostic: DiagnosticBase, options?: {
    word: string;
}) => void;
export declare const valueDiagnostics: {
    INVALID_NAMED_PARAMS: {
        (): DiagnosticBase;
        code: string;
        severity: import("../diagnostics").DiagnosticSeverity;
    };
    MISSING_REQUIRED_FORMATTER_ARG: {
        (node: ParsedValue, argIndex: number): DiagnosticBase;
        code: string;
        severity: import("../diagnostics").DiagnosticSeverity;
    };
};
export declare function getNamedArgs(node: ParsedValue): ParsedValue[][];
export declare function stringifyFunction(name: string, parsedNode: ParsedValue, perserveQuotes?: boolean): string;
export declare function getFormatterArgs(node: ParsedValue, allowComments?: boolean, reportWarning?: ReportWarning, preserveQuotes?: boolean): string[];
export declare function getStringValue(nodes: ParsedValue | ParsedValue[]): string;
export declare function listOptions(node: any): string[];
export declare function groupValues(nodes: ValueNode[], divType?: string): postcssValueParser.Node[][];
export declare function validateAllowedNodesUntil(node: ParsedValue, i: number, untilType?: string, allowed?: string[]): boolean;
export declare const strategies: {
    named: (node: any, reportWarning?: ReportWarning) => Record<string, string>;
    args: (node: any, reportWarning?: ReportWarning) => {
        value: string;
    }[];
};
//# sourceMappingURL=value.d.ts.map