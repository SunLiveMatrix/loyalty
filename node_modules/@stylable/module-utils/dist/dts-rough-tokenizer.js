"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getLocalClassStates = exports.tokenizeDTS = void 0;
const core_1 = require("@tokey/core");
function tokenizeDTS(source) {
    return findDtsTokens((0, core_1.tokenize)(source, {
        isDelimiter,
        isStringDelimiter: core_1.isStringDelimiter,
        isWhitespace: core_1.isWhitespace,
        shouldAddToken,
        createToken: core_1.createToken,
        getCommentStartType: core_1.getJSCommentStartType,
        isCommentEnd: core_1.isCommentEnd,
        getUnclosedComment: core_1.getUnclosedComment,
    }));
}
exports.tokenizeDTS = tokenizeDTS;
function getLocalClassStates(local, tokens) {
    const classes = tokens.find(({ type }) => type === 'classes');
    const token = classes?.tokens.find(({ value }) => value === `"${local}"`);
    if (token?.outputValue) {
        const stateName = token?.outputValue.value;
        const states = tokens.find(({ type }) => type === 'states');
        const classStates = states?.tokens.find(({ className: { value } }) => value === stateName);
        if (classStates) {
            return classStates.classStates;
        }
    }
    throw new Error(`Could not find states for class ${local}`);
}
exports.getLocalClassStates = getLocalClassStates;
const parenthesesClosures = {
    '}': '{',
    ']': '[',
};
const isDelimiter = (char) => char === ':' ||
    char === ';' ||
    char === '*' ||
    char === '/' ||
    char === '.' ||
    char === ',' ||
    char === '(' ||
    char === ')' ||
    char === '{' ||
    char === '}' ||
    char === '>' ||
    char === '=' ||
    char === '<' ||
    char === '|' ||
    char === '?' ||
    char === '[' ||
    char === ']' ||
    char === '+' ||
    char === '-' ||
    char === '~' ||
    char === '^' ||
    char === '&' ||
    char === '%' ||
    char === '!' ||
    char === '\n';
const shouldAddToken = (type) => (0, core_1.isComment)(type) || type === 'space' ? false : true;
function isRelevantKey(name) {
    return (name === 'classes' ||
        name === 'vars' ||
        name === 'stVars' ||
        name === 'keyframes' ||
        name === 'layers' ||
        name === 'containers');
}
function findDtsTokens(tokens) {
    const s = new core_1.Seeker(tokens);
    const dtsTokens = [];
    let t;
    const lastNewLinePosition = { line: 0, columm: 0 };
    while ((t = s.next())) {
        if (!t.type) {
            break;
        }
        if (t.type === '\n') {
            lastNewLinePosition.line += 1;
            lastNewLinePosition.columm = t.end;
        }
        else if (t.value === 'type' && s.peek().value === 'states') {
            const start = t.start;
            s.next(); // states
            s.next(); // =
            const states = {
                type: 'states',
                tokens: [],
                start,
                end: -1,
            };
            dtsTokens.push(states);
            while ((t = s.next())) {
                if (!t.type || t.type === '}') {
                    break;
                }
                if (t.type === '\n') {
                    lastNewLinePosition.line += 1;
                    lastNewLinePosition.columm = t.end;
                }
                else if (t.type === 'string') {
                    const className = {
                        ...t,
                        line: lastNewLinePosition.line,
                        column: t.start - lastNewLinePosition.columm,
                    };
                    const classStates = [];
                    let current = {
                        stateName: undefined,
                        type: [],
                    };
                    while ((t = s.next())) {
                        if (!t.type || t.type === '}') {
                            break;
                        }
                        if (t.type === '\n') {
                            lastNewLinePosition.line += 1;
                            lastNewLinePosition.columm = t.end;
                        }
                        else if (t.type === ';') {
                            current = {
                                stateName: undefined,
                                type: [],
                            };
                        }
                        else if (current.stateName) {
                            current.type.push({
                                ...t,
                                line: lastNewLinePosition.line,
                                column: t.start - lastNewLinePosition.columm,
                            });
                        }
                        else if (t.type === 'string') {
                            current.stateName = {
                                ...t,
                                line: lastNewLinePosition.line,
                                column: t.start - lastNewLinePosition.columm,
                            };
                            classStates.push(current);
                            s.next(); // ?
                            s.next(); // :
                        }
                    }
                    states.tokens.push({
                        className,
                        classStates,
                    });
                }
            }
            states.end = t.end;
        }
        else if (t.value === 'declare' &&
            s.peek().value === 'const' &&
            isRelevantKey(s.peek(2).value)) {
            const levels = {};
            const values = new WeakSet();
            const start = t.start;
            s.next(); // const
            const declareType = s.next(); // name
            s.next(); // ;
            const resTokens = []; // {...resTokens[]}
            while ((t = s.next())) {
                if (values.has(t)) {
                    // registered as value of token
                    continue;
                }
                if (!t.type) {
                    break;
                }
                if (t.type === '{' || t.type === '[') {
                    if (!levels[t.type]) {
                        levels[t.type] = 0;
                    }
                    levels[t.type]++;
                }
                if (t.type === '}' || t.type === ']') {
                    levels[parenthesesClosures[t.type]]--;
                    if (Object.values(levels).every((level) => level <= 0)) {
                        break;
                    }
                }
                if (t.type === '\n') {
                    lastNewLinePosition.line += 1;
                    lastNewLinePosition.columm = t.end;
                }
                if (t.type === 'string') {
                    const token = {
                        ...t,
                        line: lastNewLinePosition.line,
                        column: t.start - lastNewLinePosition.columm,
                    };
                    // in case this token has a string value token we add it to current token object
                    const value = s.peek(2);
                    if (value.type === 'string' || value.type === 'text') {
                        values.add(value);
                        token.outputValue = {
                            ...value,
                            line: lastNewLinePosition.line,
                            column: value.start - lastNewLinePosition.columm,
                        };
                    }
                    resTokens.push(token);
                }
            }
            const end = t.end;
            dtsTokens.push({
                type: declareType.value,
                tokens: resTokens,
                start,
                end,
            });
        }
    }
    return dtsTokens;
}
//# sourceMappingURL=dts-rough-tokenizer.js.map