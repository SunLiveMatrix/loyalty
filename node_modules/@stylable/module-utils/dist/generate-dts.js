"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateDTSContent = exports.SPACING = void 0;
const index_internal_1 = require("@stylable/core/dist/index-internal");
exports.SPACING = ' '.repeat(4);
const asString = (v) => JSON.stringify(v);
function addStatesEntries(stateEntries, stStates) {
    if (stStates) {
        for (const [stateName, stateDef] of Object.entries(stStates)) {
            if (!stateEntries.has(stateName)) {
                stateEntries.set(stateName, stateDef);
            }
        }
    }
}
function collectLocalStates(cls) {
    const stateEntries = new Map();
    let currentClass = cls;
    while (currentClass) {
        const stStates = currentClass[`-st-states`];
        if (stStates) {
            addStatesEntries(stateEntries, stStates);
        }
        const extendedClass = currentClass[`-st-extends`];
        currentClass = extendedClass && extendedClass._kind === 'class' ? extendedClass : undefined;
    }
    let stateEntriesString = '';
    // stringify states for current class
    for (const [stateName, stateDef] of stateEntries.entries()) {
        const booleanState = !stateDef;
        const mappedState = stateDef?.type === 'template' || typeof stateDef === 'string';
        if (booleanState || !mappedState) {
            stateEntriesString += `${asString(stateName)}?: ${getStateTSType(stateDef)}; `;
        }
    }
    return stateEntriesString;
}
function stringifyStates(meta) {
    let out = '';
    for (const [name, symbol] of Object.entries(meta.getAllClasses())) {
        const states = collectLocalStates(symbol);
        out += states ? `${exports.SPACING}${asString((0, index_internal_1.namespace)(name, meta.namespace))}: { ${states}};\n` : '';
    }
    return out;
}
function stringifyStringRecord(record, addParentheses = false, indent = exports.SPACING, delimiter = '\n') {
    const s = Object.entries(record)
        .map(([key, value]) => `${indent}${asString(key)}: ${stringifyTypedValue(value, indent + exports.SPACING, delimiter)};`)
        .join(delimiter);
    return addParentheses ? `{${wrapNL(s)}${indent.replace(exports.SPACING, '')}}` : s;
}
function stringifyStringArray(array, indent = exports.SPACING, delimiter = '\n') {
    return `[${wrapNL(array
        .map((value) => `${indent}${stringifyTypedValue(value, indent + exports.SPACING, delimiter)},`)
        .join(delimiter))}${indent.replace(exports.SPACING, '')}]`;
}
function stringifyTypedValue(value, indent = exports.SPACING, delimiter = '\n') {
    if (typeof value === 'string') {
        return 'string';
    }
    else if (Array.isArray(value)) {
        return stringifyStringArray(value, indent, delimiter);
    }
    else {
        return stringifyStringRecord(value, true, indent, delimiter);
    }
}
function stringifyClasses(classes, namespace, indent = exports.SPACING) {
    // this uses the scoped names from the exported stylesheet, but they may change in a future build
    return Object.keys(classes)
        .map((name) => `${indent}${asString(name)}: ${asString((0, index_internal_1.namespace)(name, namespace))};`)
        .join('\n');
}
/**
 * TODO: this function is not 100% correct and need a fix
 * support custom validators in arguments?
 * support custom types?
 */
function getStateTSType(stateDef) {
    return stateDef === null
        ? 'boolean'
        : stateDef.type === 'enum'
            ? stateDef.arguments
                .map((v) => (typeof v === 'string' ? asString(v) : 'unknown'))
                .join(' | ')
            : stateDef.type /* string | number */;
}
function wrapNL(code) {
    return code ? `\n${code}\n` : code;
}
function generateDTSContent({ exports, meta }) {
    const namespace = asString(meta.namespace);
    const classes = wrapNL(stringifyClasses(exports.classes, meta.namespace));
    const vars = wrapNL(stringifyStringRecord(exports.vars));
    const stVars = wrapNL(stringifyStringRecord(exports.stVars));
    const keyframes = wrapNL(stringifyStringRecord(exports.keyframes));
    const layers = wrapNL(stringifyStringRecord(exports.layers));
    const containers = wrapNL(stringifyStringRecord(exports.containers));
    const states = wrapNL(stringifyStates(meta));
    return `/* THIS FILE IS AUTO GENERATED DO NOT MODIFY */
declare const namespace = ${namespace};

type states = {${states}};

declare const classes: {${classes}};

declare const vars: {${vars}};

declare const stVars: {${stVars}};

declare const keyframes: {${keyframes}};

declare const layers: {${layers}};

declare const containers: {${containers}};

declare function st<T extends string = keyof states>(
    ctx: T | NullableString,
    s?: T extends keyof states ? states[T] | NullableString : NullableString,
    ...rest: NullableString[]
): string;

declare const style: typeof st;

declare function cssStates<T extends string = keyof states>(
    s: T extends keyof states ? states[T] : never,
    ctx?: T | string
): string;

export { 
    classes,
    vars,
    stVars,
    keyframes,
    layers,
    containers,
    namespace,
    st,
    style,
    cssStates
};

/* HELPERS */
type NullableString = string | undefined | null;
`;
}
exports.generateDTSContent = generateDTSContent;
//# sourceMappingURL=generate-dts.js.map