"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.replaceRecursiveUpIfEmpty = exports.removeRecursiveUpIfEmpty = exports.createLineByLineComment = exports.createCommentFromNode = exports.removeEmptyNodes = exports.removeCommentNodes = exports.StylableOptimizer = void 0;
const index_internal_1 = require("@stylable/core/dist/index-internal");
const css_selector_parser_1 = require("@tokey/css-selector-parser");
const csso_1 = __importDefault(require("csso"));
const postcss_1 = __importDefault(require("postcss"));
const name_mapper_1 = require("./name-mapper");
const { booleanStateDelimiter } = index_internal_1.STCustomState.delimiters;
const stateRegexp = new RegExp(`^(.*?)${booleanStateDelimiter}`);
class StylableOptimizer {
    constructor() {
        this.names = new name_mapper_1.NameMapper();
        this.classPrefix = 's';
        this.namespacePrefix = 'o';
    }
    minifyCSS(css) {
        // disabling restructuring as it breaks production mode by disappearing classes
        return csso_1.default.minify(css, { restructure: false }).css;
    }
    optimize(config, stylableResults, usageMapping) {
        const { meta: { globals, targetAst }, exports: jsExports, } = stylableResults;
        this.optimizeAst(config, targetAst, usageMapping, jsExports, globals);
    }
    getNamespace(namespace) {
        return this.names.get(namespace, this.namespacePrefix);
    }
    getClassName(className) {
        return this.names.get(className, this.classPrefix);
    }
    optimizeAst(config, targetAst, usageMapping, jsExports, globals) {
        if (config.removeComments) {
            this.removeComments(targetAst);
        }
        if (config.removeStylableDirectives !== undefined) {
            // ToDo(major): remove warning
            console.warn(`optimizer "removeStylableDirectives" is no longer required as "-st-*" declarations are removed during transformation`);
        }
        if (config.removeUnusedComponents && usageMapping) {
            this.removeUnusedComponents(targetAst, usageMapping);
        }
        if (config.removeEmptyNodes) {
            this.removeEmptyNodes(targetAst);
        }
        this.optimizeAstAndExports(targetAst, jsExports.classes, undefined, usageMapping, globals, config.shortNamespaces, config.classNameOptimizations);
    }
    optimizeAstAndExports(ast, exported, classes = Object.keys(exported), usageMapping, globals = {}, shortNamespaces, classNamespaceOptimizations) {
        if (!shortNamespaces && !classNamespaceOptimizations) {
            return;
        }
        ast.walkRules((rule) => {
            rule.selector = this.rewriteSelector(rule.selector, usageMapping, globals, shortNamespaces || false, classNamespaceOptimizations || false);
        });
        const namespaceRegexp = new RegExp(`^(.*?)${index_internal_1.namespaceDelimiter}`);
        classes.forEach((originName) => {
            if (exported[originName]) {
                exported[originName] = exported[originName]
                    .split(' ')
                    .map((renderedNamed) => {
                    if (globals[renderedNamed]) {
                        return renderedNamed;
                    }
                    else if (classNamespaceOptimizations) {
                        return this.getClassName(renderedNamed);
                    }
                    else if (shortNamespaces) {
                        const namespaceMatch = renderedNamed.match(namespaceRegexp);
                        if (!namespaceMatch) {
                            throw new Error(`Stylable class dose not have proper export namespace ${renderedNamed}`);
                        }
                        return renderedNamed.replace(namespaceRegexp, `${this.getNamespace(namespaceMatch[1])}${index_internal_1.namespaceDelimiter}`);
                    }
                    else {
                        throw new Error('Invalid optimization config');
                    }
                })
                    .join(' ');
            }
        });
    }
    rewriteSelector(selector, usageMapping, globals = {}, shortNamespaces, classNamespaceOptimizations) {
        const ast = (0, css_selector_parser_1.parseCssSelector)(selector);
        const namespaceRegexp = new RegExp(`^(.*?)${index_internal_1.namespaceDelimiter}`);
        (0, css_selector_parser_1.walk)(ast, (node) => {
            if (node.type === 'class' && !globals[node.value]) {
                const possibleStateNamespace = node.value.match(stateRegexp);
                let isState;
                if (possibleStateNamespace) {
                    if (possibleStateNamespace[1] in usageMapping) {
                        isState = true;
                        if (shortNamespaces) {
                            node.value = node.value.replace(stateRegexp, `${this.getNamespace(possibleStateNamespace[1])}${booleanStateDelimiter}`);
                        }
                    }
                }
                if (!isState) {
                    if (classNamespaceOptimizations) {
                        node.value = this.getClassName(node.value);
                    }
                    else if (shortNamespaces) {
                        const namespaceMatch = node.value.match(namespaceRegexp);
                        if (!namespaceMatch) {
                            throw new Error(`Stylable class dose not have proper namespace ${node.value}`);
                        }
                        node.value = node.value.replace(namespaceRegexp, `${this.getNamespace(namespaceMatch[1])}${index_internal_1.namespaceDelimiter}`);
                    }
                }
            }
        });
        return (0, css_selector_parser_1.stringifySelectorAst)(ast);
    }
    removeEmptyNodes(root) {
        removeEmptyNodes(root);
    }
    removeComments(root) {
        removeCommentNodes(root);
    }
    removeUnusedComponents(targetAst, usageMapping, shouldComment = false) {
        const matchNamespace = new RegExp(`(.+)${index_internal_1.namespaceDelimiter}(.+)`);
        targetAst.walkRules((rule) => {
            const outputSelectors = rule.selectors.filter((selector) => {
                const selectorAst = (0, css_selector_parser_1.parseCssSelector)(selector);
                return !this.isContainsUnusedParts(selectorAst[0], usageMapping, matchNamespace);
            });
            if (outputSelectors.length) {
                rule.selector = outputSelectors.join();
            }
            else {
                if (shouldComment) {
                    replaceRecursiveUpIfEmpty('NOT_IN_USE', rule);
                }
                else {
                    rule.remove();
                }
            }
        });
    }
    isContainsUnusedParts(selectorAst, usageMapping, matchNamespace) {
        // TODO: !!-!-!! last working point
        let isContainsUnusedParts = false;
        (0, css_selector_parser_1.walk)(selectorAst, (node) => {
            if (isContainsUnusedParts) {
                return css_selector_parser_1.walk.stopAll;
            }
            if (node.type === 'class') {
                const parts = matchNamespace.exec(node.value);
                if (parts) {
                    if (usageMapping[parts[1]] === false) {
                        isContainsUnusedParts = true;
                    }
                }
            }
            return;
        });
        return isContainsUnusedParts;
    }
}
exports.StylableOptimizer = StylableOptimizer;
function removeCommentNodes(root) {
    root.walkComments((comment) => {
        comment.remove();
    });
    root.walkDecls((decl) => {
        const r = decl.raws;
        if (r.value) {
            r.value.raw = decl.value;
        }
    });
}
exports.removeCommentNodes = removeCommentNodes;
function removeEmptyNodes(root) {
    const toRemove = [];
    root.walkRules((rule) => {
        const shouldRemove = (rule.nodes && rule.nodes.length === 0) ||
            (rule.nodes && rule.nodes.filter((node) => node.type !== 'comment').length === 0);
        if (shouldRemove) {
            toRemove.push(rule);
        }
    });
    toRemove.forEach((node) => {
        removeRecursiveUpIfEmpty(node);
    });
}
exports.removeEmptyNodes = removeEmptyNodes;
function createCommentFromNode(label, node) {
    return [
        postcss_1.default.comment({
            text: label + ':',
        }),
        ...createLineByLineComment(node),
    ];
}
exports.createCommentFromNode = createCommentFromNode;
function createLineByLineComment(node) {
    return node
        .toString()
        .split(/\r?\n/)
        .map((x) => {
        if (x.trim() === '') {
            return undefined;
        }
        let c;
        if (x.trim().startsWith('/*') && x.trim().endsWith('*/')) {
            c = postcss_1.default.comment({ text: x.replace(/\*\//gm, '').replace(/\/\*/gm, '') });
            // c = comment({ text: x.replace(/\*\//gm, '').replace(/\/\*/gm, '') });
        }
        else {
            c = postcss_1.default.comment({ text: x.replace(/\*\//gm, '*//*') });
        }
        return c;
    })
        .filter(Boolean);
}
exports.createLineByLineComment = createLineByLineComment;
function removeRecursiveUpIfEmpty(node) {
    const parent = node.parent;
    node.remove();
    if (parent && parent.nodes && parent.nodes.length === 0) {
        removeRecursiveUpIfEmpty(parent);
    }
}
exports.removeRecursiveUpIfEmpty = removeRecursiveUpIfEmpty;
function replaceRecursiveUpIfEmpty(label, node) {
    const parent = node.parent;
    node.raws = {};
    node.replaceWith(...(node.type === 'decl'
        ? createLineByLineComment(node)
        : createCommentFromNode(label, node)));
    if (parent &&
        parent.type !== 'document' &&
        parent.nodes &&
        parent.nodes.filter((node) => node.type !== 'comment').length === 0) {
        replaceRecursiveUpIfEmpty('EMPTY_NODE', parent);
    }
}
exports.replaceRecursiveUpIfEmpty = replaceRecursiveUpIfEmpty;
//# sourceMappingURL=stylable-optimizer.js.map