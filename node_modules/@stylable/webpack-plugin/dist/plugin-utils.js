"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isDependencyOf = exports.getEntryPointModules = exports.emitCSSFile = exports.getOnlyChunk = exports.getStylableModules = exports.provideStylableModules = exports.getCSSViewModuleWebpack = exports.createCalcDepthContext = exports.getTopLevelInputFilesystem = exports.createOptimizationMapping = exports.normalizeNamespaceCollisionOption = exports.reportNamespaceCollision = exports.getSortedModules = exports.getFileName = exports.findIfStylableModuleUsed = exports.getStylableBuildData = exports.getStylableBuildMeta = exports.getWebpackBuildMeta = exports.createStaticCSS = exports.staticCSSWith = exports.createStylableResolverCacheMap = exports.createDecacheRequire = exports.injectLoader = exports.LOADER_NAME = exports.outputOptionsAwareHashContent = exports.isLoadedWithKnownAssetLoader = exports.extractDataUrlFromAssetModuleSource = exports.extractFilenameFromAssetModule = exports.replaceMappedCSSAssetPlaceholders = exports.replaceCSSAssetPlaceholders = exports.getStaticPublicPath = exports.isAssetModule = exports.isLoadedNativeCSSModule = exports.isStylableModule = exports.isSameResourceModule = exports.uniqueFilterMap = void 0;
const decache_1 = __importDefault(require("decache"));
const build_tools_1 = require("@stylable/build-tools");
const path_1 = require("path");
const re_ext_plugin_1 = require("./re-ext-plugin");
function* uniqueFilterMap(iter, map = (item) => item, filter = (item) => item !== undefined && item !== null) {
    const s = new Set();
    for (const item of iter) {
        const mapped = map(item);
        if (!filter(mapped)) {
            continue;
        }
        if (s.has(mapped)) {
            continue;
        }
        yield mapped;
        s.add(mapped);
    }
}
exports.uniqueFilterMap = uniqueFilterMap;
function isSameResourceModule(moduleA, moduleB) {
    return moduleA.resource === moduleB.resource;
}
exports.isSameResourceModule = isSameResourceModule;
function isStylableModule(module) {
    return module?.resource?.endsWith('.st.css');
}
exports.isStylableModule = isStylableModule;
function isLoadedNativeCSSModule(module, moduleGraph) {
    return module.resource?.endsWith('.css') && isStylableModule(moduleGraph.getIssuer(module));
}
exports.isLoadedNativeCSSModule = isLoadedNativeCSSModule;
function isAssetModule(module) {
    return module.type.startsWith('asset/') || module.type === 'asset';
}
exports.isAssetModule = isAssetModule;
function getStaticPublicPath(compilation) {
    let publicPath = '';
    if (typeof compilation.outputOptions.publicPath === 'string') {
        publicPath = compilation.outputOptions.publicPath;
        publicPath = publicPath === 'auto' ? '' : publicPath;
        publicPath = publicPath === '' || publicPath.endsWith('/') ? publicPath : publicPath + '/';
    }
    else {
        throw new Error('Public path as function is not supported yet.');
    }
    return publicPath;
}
exports.getStaticPublicPath = getStaticPublicPath;
function replaceCSSAssetPlaceholders({ css, urls }, publicPath, getAssetOutputPath) {
    return css.replace(/__stylable_url_asset_(\d+?)__/g, (_match, index) => getAssetOutputPath(urls[Number(index)], publicPath));
}
exports.replaceCSSAssetPlaceholders = replaceCSSAssetPlaceholders;
function replaceMappedCSSAssetPlaceholders({ stylableBuildData, staticPublicPath, assetsModules, chunkGraph, moduleGraph, runtime, runtimeTemplate, dependencyTemplates, }) {
    return replaceCSSAssetPlaceholders(stylableBuildData, staticPublicPath, (resourcePath, publicPath) => {
        const assetModule = assetsModules.get(resourcePath);
        if (!assetModule) {
            throw new Error('Missing asset module for ' + resourcePath);
        }
        if (isLoadedWithKnownAssetLoader(assetModule)) {
            return extractFilenameFromAssetModule(assetModule, publicPath);
        }
        else {
            const data = new Map();
            const assetModuleSource = assetModule.generator.generate(assetModule, {
                chunkGraph,
                moduleGraph,
                runtime,
                runtimeRequirements: new Set(),
                runtimeTemplate,
                dependencyTemplates,
                type: 'asset/resource',
                getData: () => data,
            });
            if (!assetModule.buildInfo) {
                throw new Error('Missing asset module build info for ' + resourcePath);
            }
            if (assetModule.buildInfo.dataUrl) {
                // Investigate using the data map from getData currently there is an unknown in term from escaping keeping extractDataUrlFromAssetModuleSource
                return extractDataUrlFromAssetModuleSource(assetModuleSource.source().toString());
            }
            return publicPath + assetModule.buildInfo.filename;
        }
    });
}
exports.replaceMappedCSSAssetPlaceholders = replaceMappedCSSAssetPlaceholders;
function extractFilenameFromAssetModule(module, publicPath) {
    const source = module.originalSource().source().toString();
    let match = source.match(/__webpack_public_path__\s*\+\s*"(.*?)"/);
    if (match) {
        return publicPath + match[1];
    }
    match = source.match(/module.exports\s*=\s*"(.*?)"/);
    if (match) {
        return match[1];
    }
    match = source.match(/export\s+default\s+"(.*?)"/);
    if (match) {
        return match[1];
    }
    throw new Error(`unknown asset module format ${source}\ntransformed from ${module.resource}`);
}
exports.extractFilenameFromAssetModule = extractFilenameFromAssetModule;
function extractDataUrlFromAssetModuleSource(source) {
    let match = source.match(/.exports\s*=\s*"(.*?)"/);
    if (match) {
        return match[1];
    }
    match = source.toString().match(/export\s+default\s+"(.*?)"/);
    if (match) {
        return match[1];
    }
    throw new Error('unknown data url asset module format ' + source);
}
exports.extractDataUrlFromAssetModuleSource = extractDataUrlFromAssetModuleSource;
function isLoadedWithKnownAssetLoader(module) {
    if ('loaders' in module) {
        return module.loaders.some(({ loader }) => /[\\/](file-loader)|(url-loader)[\\/]/.test(loader));
    }
    return false;
}
exports.isLoadedWithKnownAssetLoader = isLoadedWithKnownAssetLoader;
function outputOptionsAwareHashContent(createHash, outputOptions, content) {
    const hash = createHash(outputOptions.hashFunction || 'md4');
    if (outputOptions.hashSalt) {
        hash.update(outputOptions.hashSalt);
    }
    hash.update(content);
    const fullHash = /** @type {string} */ hash.digest(outputOptions.hashDigest);
    const contentHash = fullHash.slice(0, outputOptions.hashDigestLength);
    return contentHash.toString();
}
exports.outputOptionsAwareHashContent = outputOptionsAwareHashContent;
exports.LOADER_NAME = 'stylable-plugin-loader';
function injectLoader(compiler) {
    var _a, _b;
    const options = compiler.options;
    if (!options.module.rules) {
        compiler.options.module.rules = [];
    }
    const loaderPath = require.resolve('./loader');
    options.module.rules.unshift({
        test: /\.st\.css$/,
        loader: exports.LOADER_NAME,
        sideEffects: true,
    });
    options.resolve || (options.resolve = {});
    (_a = options.resolve).plugins || (_a.plugins = []);
    // dual mode support
    options.resolve.plugins.push(new re_ext_plugin_1.ReExt(/\.st\.css\.(c|m)?js$/, '.st.css'));
    options.resolveLoader ?? (options.resolveLoader = {});
    (_b = options.resolveLoader).alias ?? (_b.alias = {});
    if (Array.isArray(options.resolveLoader.alias)) {
        options.resolveLoader.alias.unshift({
            name: exports.LOADER_NAME,
            alias: loaderPath,
        });
    }
    else {
        options.resolveLoader.alias[exports.LOADER_NAME] = loaderPath;
    }
}
exports.injectLoader = injectLoader;
function createDecacheRequire(compiler) {
    const cacheIds = new Set();
    compiler.hooks.done.tap('decache require', () => {
        if (!compiler.watchMode) {
            return;
        }
        for (const id of cacheIds) {
            (0, decache_1.default)(id);
        }
        cacheIds.clear();
    });
    return (id) => {
        if (compiler.watchMode) {
            cacheIds.add(id);
        }
        return require(id);
    };
}
exports.createDecacheRequire = createDecacheRequire;
function createStylableResolverCacheMap(compiler) {
    const cache = new Map();
    compiler.hooks.done.tap('StylableResolverCache cleanup', () => {
        cache.clear();
    });
    return cache;
}
exports.createStylableResolverCacheMap = createStylableResolverCacheMap;
function staticCSSWith(staticPublicPath, assetsModules, chunkGraph, moduleGraph, runtime, runtimeTemplate, dependencyTemplates) {
    return (stylableModules) => createStaticCSS(staticPublicPath, stylableModules, assetsModules, chunkGraph, moduleGraph, runtime, runtimeTemplate, dependencyTemplates);
}
exports.staticCSSWith = staticCSSWith;
function createStaticCSS(staticPublicPath, stylableModules, assetsModules, chunkGraph, moduleGraph, runtime, runtimeTemplate, dependencyTemplates) {
    const cssChunks = Array.from(stylableModules.keys())
        .filter((m) => getStylableBuildMeta(m).isUsed !== false)
        .sort((m1, m2) => getStylableBuildMeta(m1).depth - getStylableBuildMeta(m2).depth)
        .map((m) => {
        return replaceMappedCSSAssetPlaceholders({
            assetsModules,
            staticPublicPath,
            chunkGraph,
            moduleGraph,
            dependencyTemplates,
            runtime,
            runtimeTemplate,
            stylableBuildData: getStylableBuildData(stylableModules, m),
        });
    });
    return cssChunks;
}
exports.createStaticCSS = createStaticCSS;
function getWebpackBuildMeta(module) {
    const buildMeta = module.buildMeta;
    if (!buildMeta) {
        throw new Error(`Stylable module ${module.identifier()} does not contains build meta`);
    }
    return buildMeta;
}
exports.getWebpackBuildMeta = getWebpackBuildMeta;
function getStylableBuildMeta(module) {
    const meta = module.buildMeta?.stylable;
    if (!meta) {
        throw new Error(`Stylable module ${module.identifier()} does not contains build meta`);
    }
    return meta;
}
exports.getStylableBuildMeta = getStylableBuildMeta;
function getStylableBuildData(stylableModules, module) {
    const data = stylableModules.get(module);
    if (!data) {
        throw new Error(`Stylable module ${module.identifier()} does not contains build data`);
    }
    return data;
}
exports.getStylableBuildData = getStylableBuildData;
function findIfStylableModuleUsed(m, compilation, UnusedDependency) {
    const moduleGraph = compilation.moduleGraph;
    const chunkGraph = compilation.chunkGraph;
    const inConnections = uniqueFilterMap(moduleGraph.getIncomingConnections(m), ({ resolvedOriginModule, dependency }) => dependency instanceof UnusedDependency ? undefined : resolvedOriginModule);
    // TODO: check if we can optimize by checking if a module contained in at least one chunk.
    let isInUse = false;
    for (const connectionModule of inConnections) {
        if (connectionModule.buildMeta?.sideEffectFree) {
            const info = moduleGraph.getExportsInfo(connectionModule);
            const usedExports = info.getUsedExports( /*if passed undefined it finds usages in all chunks*/);
            if (usedExports === false) {
                continue;
            }
            else if (usedExports === true || usedExports === null) {
                /** noop */
            }
            else if (usedExports.size === 0) {
                continue;
            }
        }
        const chunksCount = chunkGraph.getNumberOfModuleChunks(connectionModule);
        if (chunksCount > 0) {
            isInUse = true;
            break;
        }
    }
    return isInUse;
}
exports.findIfStylableModuleUsed = findIfStylableModuleUsed;
function getFileName(filename, data) {
    return filename.replace(/\[(.*?)]/g, (fullMatch, inner) => {
        const [type, len] = inner.split(':');
        const value = data[type];
        if (value) {
            const length = Number(len);
            return !isNaN(length) ? value.slice(0, length) : value;
        }
        else {
            return fullMatch;
        }
    });
}
exports.getFileName = getFileName;
/**
 * sorts by depth, falling back to alpha numeric
 */
function getSortedModules(stylableModules) {
    return Array.from(stylableModules.keys()).sort((m1, m2) => {
        const depthDiff = getStylableBuildMeta(m2).depth - getStylableBuildMeta(m1).depth;
        if (depthDiff === 0) {
            if (m1.resource > m2.resource) {
                return 1;
            }
            else if (m1.resource < m2.resource) {
                return -1;
            }
            else {
                return 0;
            }
        }
        else {
            return depthDiff;
        }
    });
}
exports.getSortedModules = getSortedModules;
function reportNamespaceCollision(namespaceToFileMapping, compilation, mode) {
    if (mode === 'ignore') {
        return;
    }
    for (const [namespace, resources] of namespaceToFileMapping) {
        if (resources.size > 1) {
            const resourcesReport = [...resources]
                .map((module) => getModuleRequestPath(module, compilation))
                .join('\n');
            const error = new compilation.compiler.webpack.WebpackError(`Duplicate namespace ${JSON.stringify(namespace)} found in multiple different resources:\n${resourcesReport}\nThis issue indicates multiple versions of the same library in the compilation, or different paths importing the same stylesheet like: "esm" or "cjs".`);
            error.hideStack = true;
            compilation[mode].push(error);
        }
    }
}
exports.reportNamespaceCollision = reportNamespaceCollision;
function normalizeNamespaceCollisionOption(opt) {
    if (opt === true) {
        return 'ignore';
    }
    else if (opt === 'warn') {
        return 'warnings';
    }
    else {
        return 'errors';
    }
}
exports.normalizeNamespaceCollisionOption = normalizeNamespaceCollisionOption;
function getModuleRequestPath(module, { requestShortener, moduleGraph }) {
    const visited = new Set();
    const path = [];
    let current = module;
    while (current) {
        if (visited.has(current)) {
            path.unshift(current.readableIdentifier(requestShortener) + '<-- Circular');
            break;
        }
        visited.add(current);
        const currentId = current.readableIdentifier(requestShortener);
        path.unshift(currentId);
        current = moduleGraph.getIssuer(current);
    }
    return path.map((p, i) => '  '.repeat(i) + p).join('\n') + ' <-- Duplicate';
}
function createOptimizationMapping(sortedModules, optimizer) {
    return sortedModules.reduce((acc, module) => {
        const { namespace, isUsed } = getStylableBuildMeta(module);
        if (!acc.usageMapping[namespace]) {
            acc.usageMapping[namespace] = isUsed ?? true;
        }
        acc.namespaceMapping[namespace] = optimizer.getNamespace(namespace);
        if (!isUsed) {
            // skip collision map for unused stylesheets
            return acc;
        }
        if (acc.potentialNamespaceCollision.has(namespace)) {
            acc.potentialNamespaceCollision.get(namespace).add(module);
        }
        else {
            acc.potentialNamespaceCollision.set(namespace, new Set([module]));
        }
        return acc;
    }, {
        usageMapping: {},
        namespaceMapping: {},
        potentialNamespaceCollision: new Map(),
    });
}
exports.createOptimizationMapping = createOptimizationMapping;
function getTopLevelInputFilesystem(compiler) {
    let fileSystem = compiler.inputFileSystem;
    while (fileSystem.fileSystem) {
        fileSystem = fileSystem.fileSystem;
    }
    return fileSystem;
}
exports.getTopLevelInputFilesystem = getTopLevelInputFilesystem;
function createCalcDepthContext(moduleGraph) {
    return {
        getDependencies: (module) => uniqueFilterMap(moduleGraph.getOutgoingConnections(module), ({ module }) => module),
        getImporters: (module) => uniqueFilterMap(moduleGraph.getIncomingConnections(module), ({ originModule }) => originModule),
        getModulePathNoExt: (module) => {
            if (isStylableModule(module)) {
                return module.resource.replace(/\.st\.css$/, '');
            }
            const { dir, name } = (0, path_1.parse)(module?.resource || '');
            return (0, path_1.join)(dir, name);
        },
        isStylableModule: (module) => isStylableModule(module),
    };
}
exports.createCalcDepthContext = createCalcDepthContext;
function getCSSViewModuleWebpack(moduleGraph) {
    const context = createCalcDepthContext(moduleGraph);
    return (module) => (0, build_tools_1.getCSSViewModule)(module, context);
}
exports.getCSSViewModuleWebpack = getCSSViewModuleWebpack;
/**
 * Provide a simple way to share build meta with other plugins without using module state like WeakMap<Compilation, DATA>
 */
function provideStylableModules(compilation, stylableModules) {
    compilation[Symbol.for('stylableModules')] = stylableModules;
}
exports.provideStylableModules = provideStylableModules;
function getStylableModules(compilation) {
    return compilation[Symbol.for('stylableModules')];
}
exports.getStylableModules = getStylableModules;
function getOnlyChunk(compilation) {
    return compilation.entrypoints.size === 1
        ? Array.from(compilation.entrypoints.values())[0].getEntrypointChunk()
        : undefined;
}
exports.getOnlyChunk = getOnlyChunk;
function emitCSSFile(compilation, cssSource, filenameTemplate, createHash, chunk) {
    const contentHash = outputOptionsAwareHashContent(createHash, compilation.runtimeTemplate.outputOptions, cssSource);
    const filename = getFileName(filenameTemplate, {
        contenthash: contentHash,
        hash: compilation.hash,
        name: chunk?.name,
    });
    compilation.emitAsset(filename, new compilation.compiler.webpack.sources.RawSource(cssSource, false));
    return filename;
}
exports.emitCSSFile = emitCSSFile;
function getEntryPointModules(entryPoint, chunkGraph, onModule) {
    for (const chunk of entryPoint.getEntrypointChunk().getAllReferencedChunks()) {
        for (const module of chunkGraph.getChunkModulesIterable(chunk)) {
            onModule(module);
        }
    }
}
exports.getEntryPointModules = getEntryPointModules;
function isDependencyOf(entryPoint, entrypoints) {
    // entryPoint.options.dependsOn is not in webpack types;
    for (const parent of entryPoint.getParents()) {
        for (const entry of entrypoints) {
            if (parent.id === entry.id) {
                return true;
            }
        }
    }
    return false;
}
exports.isDependencyOf = isDependencyOf;
//# sourceMappingURL=plugin-utils.js.map