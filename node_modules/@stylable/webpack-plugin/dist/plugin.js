"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StylableWebpackPlugin = void 0;
const core_1 = require("@stylable/core");
const index_internal_1 = require("@stylable/core/dist/index-internal");
const node_1 = require("@stylable/node");
const build_tools_1 = require("@stylable/build-tools");
const optimizer_1 = require("@stylable/optimizer");
const lodash_clonedeep_1 = __importDefault(require("lodash.clonedeep"));
const plugin_utils_1 = require("./plugin-utils");
const mini_css_support_1 = require("./mini-css-support");
const postcss_1 = require("postcss");
const webpack_entities_1 = require("./webpack-entities");
const cli_1 = require("@stylable/cli");
const defaultOptimizations = (isProd) => ({
    removeUnusedComponents: true,
    removeComments: isProd,
    classNameOptimizations: isProd,
    shortNamespaces: isProd,
    removeEmptyNodes: isProd,
    minify: isProd,
});
const defaultOptions = (userOptions, isProd) => ({
    filename: userOptions.filename ?? 'stylable.css',
    cssInjection: userOptions.cssInjection ?? (isProd ? 'css' : 'js'),
    assetsMode: userOptions.assetsMode ?? 'url',
    stylableConfig: userOptions.stylableConfig ?? ((config) => config),
    runtimeStylesheetId: userOptions.runtimeStylesheetId ?? (isProd ? 'namespace' : 'module'),
    diagnosticsMode: userOptions.diagnosticsMode ?? 'auto',
    runtimeId: userOptions.runtimeId ?? '0',
    unsafeMuteDiagnostics: userOptions.unsafeMuteDiagnostics ?? {},
    optimize: userOptions.optimize
        ? { ...defaultOptimizations(isProd), ...userOptions.optimize }
        : defaultOptimizations(isProd),
    optimizer: userOptions.optimizer ?? new optimizer_1.StylableOptimizer(),
    target: userOptions.target ?? 'modern',
    assetFilter: userOptions.assetFilter ?? (() => true),
    extractMode: userOptions.extractMode ?? 'single',
    stcConfig: userOptions.stcConfig ?? false,
    depthStrategy: userOptions.depthStrategy ?? 'css+js',
    includeGlobalSideEffects: userOptions.includeGlobalSideEffects ?? true,
    experimentalAttachCssToContainingChunks: userOptions.experimentalAttachCssToContainingChunks ?? false,
});
class StylableWebpackPlugin {
    constructor(userOptions = {}, injectConfigHooks = true) {
        this.userOptions = userOptions;
        this.injectConfigHooks = injectConfigHooks;
    }
    apply(compiler) {
        /**
         * Create all webpack entities
         */
        this.entities = (0, webpack_entities_1.getWebpackEntities)(compiler.webpack);
        /**
         * This plugin is based on a loader so we inject the loader here
         */
        if (this.injectConfigHooks) {
            (0, plugin_utils_1.injectLoader)(compiler);
        }
        /**
         * We want to catch any configuration changes made by other plugins
         * only after they run we process our options and create the Stylable instance
         */
        compiler.hooks.afterPlugins.tap(StylableWebpackPlugin.name, () => {
            this.processOptions(compiler);
            this.createStylable(compiler);
            this.createStcBuilder(compiler);
        });
        compiler.hooks.beforeRun.tapPromise(StylableWebpackPlugin.name, async () => {
            await this.stcBuilder?.build();
        });
        compiler.hooks.watchRun.tapPromise({ name: StylableWebpackPlugin.name, stage: 0 }, async (compiler) => {
            await this.stcBuilder?.rebuild([
                ...(compiler.modifiedFiles ?? []),
                ...(compiler.removedFiles ?? []),
            ]);
        });
        compiler.hooks.thisCompilation.tap(StylableWebpackPlugin.name, (compilation) => {
            /**
             * Register STC projects directories as dependencies
             */
            if (this.stcBuilder) {
                compilation.contextDependencies.addAll(this.stcBuilder.getProjectsSources());
            }
        });
        compiler.hooks.afterDone.tap(StylableWebpackPlugin.name, () => {
            /**
             * If there are diagnostics left, report them.
             */
            if (this.stcBuilder) {
                const logger = compiler.getInfrastructureLogger(StylableWebpackPlugin.name);
                this.stcBuilder.reportDiagnostics({
                    emitError: (e) => logger.error(e),
                    emitWarning: (w) => logger.warn(w),
                }, this.options.diagnosticsMode, true);
            }
        });
        compiler.hooks.compilation.tap(StylableWebpackPlugin.name, (compilation, { normalModuleFactory }) => {
            /**
             * Since we embed assets in the bundle css we must know the public path in advance
             */
            const staticPublicPath = (0, plugin_utils_1.getStaticPublicPath)(compilation);
            const assetsModules = new Map();
            const stylableModules = new Map();
            /** allow other plugins to access the stylableModules */
            (0, plugin_utils_1.provideStylableModules)(compilation, stylableModules);
            /**
             * Handle things that related to each module
             */
            this.modulesIntegration(compiler.webpack, compilation, stylableModules, assetsModules);
            /**
             * Handle things that related to chunking and bundling
             */
            this.chunksIntegration(compiler.webpack, compilation, staticPublicPath, stylableModules, assetsModules, this.options.experimentalAttachCssToContainingChunks);
            /**
             * Setup all the boilerplate Webpack dependencies and factories
             */
            this.setupDependencies(compilation, normalModuleFactory, staticPublicPath, stylableModules, assetsModules);
            /**
             * Here we inject our runtime code for the js modules and injection of css to head
             */
            this.entities.injectRuntimeModules(StylableWebpackPlugin.name, compilation);
        });
    }
    processOptions(compiler) {
        const defaults = defaultOptions(this.userOptions, compiler.options.mode === 'production');
        const options = (0, build_tools_1.loadStylableConfig)(compiler.context, (config) => {
            return isWebpackConfigProcessor(config)
                ? config.webpackPlugin(defaults, compiler, (0, plugin_utils_1.getTopLevelInputFilesystem)(compiler))
                : undefined;
        })?.config || defaults;
        this.options = options;
    }
    getStylableConfig(compiler) {
        const configuration = (0, cli_1.resolveConfig)(compiler.context, typeof this.options.stcConfig === 'string' ? this.options.stcConfig : undefined, (0, plugin_utils_1.getTopLevelInputFilesystem)(compiler));
        return configuration;
    }
    createStcBuilder(compiler) {
        if (!this.options.stcConfig) {
            return;
        }
        const config = this.getStylableConfig(compiler);
        /**
         * In case the user uses STC we can run his config in this process.
         */
        if (config) {
            this.stcBuilder = cli_1.STCBuilder.create({
                rootDir: compiler.context,
                watchMode: compiler.watchMode,
                configFilePath: config.path,
            });
        }
    }
    createStylable(compiler) {
        if (this.stylable) {
            return;
        }
        const resolverOptions = {
            ...compiler.options.resolve,
            aliasFields: compiler.options.resolve.byDependency?.esm?.aliasFields ||
                compiler.options.resolve.aliasFields,
        };
        const topLevelFs = (0, plugin_utils_1.getTopLevelInputFilesystem)(compiler);
        const stylableConfig = this.getStylableConfig(compiler)?.config;
        (0, index_internal_1.validateDefaultConfig)(stylableConfig?.defaultConfig);
        this.stylable = new core_1.Stylable(this.options.stylableConfig({
            projectRoot: compiler.context,
            /**
             * We need to get the top level file system
             * because issue with the sync resolver we create inside Stylable
             */
            fileSystem: topLevelFs,
            mode: compiler.options.mode === 'production' ? 'production' : 'development',
            resolveOptions: {
                ...resolverOptions,
                extensions: [], // use Stylable's default extensions
            },
            resolveNamespace: (0, node_1.createNamespaceStrategyNode)({
                hashSalt: compiler.options.output.hashSalt || '',
            }),
            requireModule: (0, plugin_utils_1.createDecacheRequire)(compiler),
            optimizer: this.options.optimizer,
            resolverCache: (0, plugin_utils_1.createStylableResolverCacheMap)(compiler),
            /**
             * config order is user determined
             * each configuration points receives the default options,
             * and lets the user mix and match the options as they wish
             */
            ...stylableConfig?.defaultConfig,
        }, compiler));
    }
    modulesIntegration(webpack, compilation, stylableModules, assetsModules) {
        const { moduleGraph } = compilation;
        /**
         * Here we are creating the context that our loader needs
         */
        webpack.NormalModule.getCompilationHooks(compilation).loader.tap(StylableWebpackPlugin.name, (webpackLoaderContext, module) => {
            const loaderContext = webpackLoaderContext;
            if ((0, plugin_utils_1.isStylableModule)(module) || (0, plugin_utils_1.isLoadedNativeCSSModule)(module, moduleGraph)) {
                loaderContext.stylable = this.stylable;
                loaderContext.assetsMode = this.options.assetsMode;
                loaderContext.diagnosticsMode = this.options.diagnosticsMode;
                loaderContext.target = this.options.target;
                loaderContext.assetFilter = this.options.assetFilter;
                loaderContext.includeGlobalSideEffects = this.options.includeGlobalSideEffects;
                /**
                 * Every Stylable file that our loader handles will be call this function to add additional build data
                 */
                loaderContext.flagStylableModule = (loaderData) => {
                    const stylableBuildMeta = {
                        depth: 0,
                        isUsed: undefined,
                        ...loaderData,
                    };
                    (0, plugin_utils_1.getWebpackBuildMeta)(module).stylable = stylableBuildMeta;
                    /**
                     * We want to add the unused imports because we need them to calculate the depth correctly
                     * They might be used by other stylesheets so they might end up in the final build
                     */
                    for (const resolvedAbsPath of stylableBuildMeta.unusedImports) {
                        module.addDependency(new this.entities.UnusedDependency(resolvedAbsPath, 0));
                    }
                    /**
                     * Since we don't use the Webpack js api of url assets we have our own CSSURLDependency
                     */
                    if (this.options.assetsMode === 'url') {
                        for (const resourcePath of stylableBuildMeta.urls) {
                            module.addDependency(new this.entities.CSSURLDependency(resourcePath));
                        }
                    }
                    /**
                     * This dependency is responsible for injecting the runtime to the main chunk and each module
                     */
                    module.addDependency(new this.entities.StylableRuntimeDependency(stylableBuildMeta));
                    /**
                     * If STC Builder is running in background we need to add the relevant files to webpack file dependencies watcher,
                     * and emit diagnostics from the sources and not from the output.
                     */
                    if (!this.stcBuilder) {
                        return;
                    }
                    const sources = this.stcBuilder.getSourcesFiles(module.resource);
                    if (sources) {
                        /**
                         * Remove output file diagnostics only if has source files
                         */
                        module.clearWarningsAndErrors();
                        for (const sourceFilePath of sources) {
                            /**
                             * Register the source file as a dependency
                             */
                            compilation.fileDependencies.add(sourceFilePath);
                            /**
                             * Add source file diagnostics to the output file module (more accurate diagnostic)
                             */
                            this.stcBuilder.reportDiagnostic(sourceFilePath, loaderContext, this.options.diagnosticsMode, true);
                        }
                    }
                };
            }
        });
        /**
         * We collect the modules that we are going to handle here once.
         */
        compilation.hooks.optimizeDependencies.tap(StylableWebpackPlugin.name, (modules) => {
            for (const module of modules) {
                if (((0, plugin_utils_1.isStylableModule)(module) || (0, plugin_utils_1.isLoadedNativeCSSModule)(module, moduleGraph)) &&
                    module.buildMeta?.stylable) {
                    stylableModules.set(module, null);
                }
                if ((0, plugin_utils_1.isAssetModule)(module)) {
                    assetsModules.set(module.resource, module);
                }
                module.dependencies.forEach((dep) => {
                    if (dep instanceof this.entities.UnusedDependency) {
                        compilation.moduleGraph.getConnection(dep)?.setActive(false);
                    }
                });
                /**
                 * @remove
                 * This part supports old loaders and should be removed
                 */
                if ((0, plugin_utils_1.isLoadedWithKnownAssetLoader)(module) && !assetsModules.has(module.resource)) {
                    assetsModules.set(module.resource, module);
                }
            }
        });
        /**
         * @remove
         * This part supports old loaders and should be removed
         */
        if (this.options.assetsMode === 'loader') {
            compilation.hooks.optimizeDependencies.tap(StylableWebpackPlugin.name, () => {
                for (const [module] of stylableModules) {
                    const connections = moduleGraph.getOutgoingConnections(module);
                    for (const connection of connections) {
                        if (!(0, plugin_utils_1.isAssetModule)(connection.module) &&
                            (0, plugin_utils_1.isLoadedWithKnownAssetLoader)(connection.module)) {
                            connection.setActive(false);
                        }
                    }
                }
            });
        }
        /**
         *  After we have the initial chunks we can calculate the depth and usage of each stylesheet and create buildData
         */
        compilation.hooks.afterChunks.tap({ name: StylableWebpackPlugin.name, stage: 0 }, () => {
            const cache = new Map();
            const context = (0, plugin_utils_1.createCalcDepthContext)(moduleGraph);
            for (const [module] of stylableModules) {
                const stylableBuildMeta = (0, plugin_utils_1.getStylableBuildMeta)(module);
                stylableBuildMeta.isUsed = (0, plugin_utils_1.findIfStylableModuleUsed)(module, compilation, this.entities.UnusedDependency);
                /** legacy flow */
                stylableBuildMeta.depth =
                    this.options.depthStrategy === 'css'
                        ? stylableBuildMeta.cssDepth
                        : (0, build_tools_1.calcDepth)(module, context, [], cache);
                const { css, urls, exports, namespace } = (0, plugin_utils_1.getStylableBuildMeta)(module);
                stylableModules.set(module, {
                    exports: (0, lodash_clonedeep_1.default)(exports),
                    urls: (0, lodash_clonedeep_1.default)(urls),
                    namespace,
                    css,
                    isUsed: stylableBuildMeta.isUsed,
                    depth: stylableBuildMeta.depth,
                });
            }
        });
        compilation.hooks.afterChunks.tap(StylableWebpackPlugin.name, () => {
            const optimizer = this.stylable.optimizer;
            const optimizeOptions = this.options.optimize;
            const sortedModules = (0, build_tools_1.sortModulesByDepth)(Array.from(stylableModules.keys()), (m) => (0, plugin_utils_1.getStylableBuildMeta)(m).depth, (m) => m.resource);
            const { usageMapping, namespaceMapping, potentialNamespaceCollision } = (0, plugin_utils_1.createOptimizationMapping)(sortedModules, optimizer);
            (0, plugin_utils_1.reportNamespaceCollision)(potentialNamespaceCollision, compilation, (0, plugin_utils_1.normalizeNamespaceCollisionOption)(this.options.unsafeMuteDiagnostics.DUPLICATE_MODULE_NAMESPACE));
            for (const module of sortedModules) {
                const { css, globals, namespace, type } = (0, plugin_utils_1.getStylableBuildMeta)(module);
                try {
                    const buildData = stylableModules.get(module);
                    let cssOutput = css;
                    if (type === 'stylable') {
                        const ast = (0, postcss_1.parse)(css, { from: module.resource });
                        optimizer.optimizeAst(optimizeOptions, ast, usageMapping, buildData.exports, globals);
                        cssOutput = ast.toString();
                    }
                    buildData.css = optimizeOptions.minify
                        ? optimizer.minifyCSS(cssOutput)
                        : cssOutput;
                    if (optimizeOptions.shortNamespaces) {
                        buildData.namespace = namespaceMapping[namespace];
                    }
                }
                catch (e) {
                    compilation.errors.push(e);
                }
            }
        });
    }
    chunksIntegration(webpack, compilation, staticPublicPath, stylableModules, assetsModules, experimentalAttachCssToContainingChunks) {
        /**
         * As a work around unknown behavior
         * if this plugin will run inside a child compilation we do not emit css assets
         */
        if (!compilation.compiler.isChild()) {
            if (this.options.cssInjection === 'css') {
                const createStaticCSS = (0, plugin_utils_1.staticCSSWith)(staticPublicPath, assetsModules, compilation.chunkGraph, compilation.moduleGraph, 'CSS' /*runtime*/, compilation.runtimeTemplate, compilation.dependencyTemplates);
                if (this.options.extractMode === 'entries') {
                    let modulesPerChunks;
                    compilation.hooks.afterOptimizeTree.tap(StylableWebpackPlugin.name, () => {
                        modulesPerChunks = [];
                        for (const entryPoint of compilation.entrypoints.values()) {
                            if ((0, plugin_utils_1.isDependencyOf)(entryPoint, compilation.entrypoints.values())) {
                                continue;
                            }
                            const modules = new Map();
                            (0, plugin_utils_1.getEntryPointModules)(entryPoint, compilation.chunkGraph, (module) => {
                                const m = module;
                                if (stylableModules.has(m)) {
                                    modules.set(m, (0, plugin_utils_1.getStylableBuildData)(stylableModules, m));
                                }
                            });
                            if (modules.size) {
                                modulesPerChunks.push({ entryPoint, modules });
                            }
                        }
                    });
                    compilation.hooks.processAssets.tap({
                        name: StylableWebpackPlugin.name,
                        stage: webpack.Compilation.PROCESS_ASSETS_STAGE_DERIVED,
                    }, () => {
                        for (const { entryPoint, modules } of modulesPerChunks) {
                            const entryChunk = entryPoint.getEntrypointChunk();
                            entryChunk.files.add((0, plugin_utils_1.emitCSSFile)(compilation, createStaticCSS(modules).join('\n'), this.options.filename, webpack.util.createHash, entryChunk));
                        }
                    });
                }
                else if (this.options.extractMode === 'single') {
                    compilation.hooks.processAssets.tap({
                        name: StylableWebpackPlugin.name,
                        stage: webpack.Compilation.PROCESS_ASSETS_STAGE_DERIVED,
                    }, () => {
                        if (!stylableModules.size) {
                            return;
                        }
                        const chunk = (0, plugin_utils_1.getOnlyChunk)(compilation);
                        const cssSource = createStaticCSS(stylableModules).join('\n');
                        const cssBundleFilename = (0, plugin_utils_1.emitCSSFile)(compilation, cssSource, this.options.filename, webpack.util.createHash, chunk);
                        if (!experimentalAttachCssToContainingChunks) {
                            for (const entryPoint of compilation.entrypoints.values()) {
                                entryPoint.getEntrypointChunk().files.add(cssBundleFilename);
                            }
                        }
                        else {
                            for (const chunk of compilation.chunks) {
                                for (const module of chunk.modulesIterable) {
                                    if (isNormalModule(module) &&
                                        module.resource?.endsWith('.st.css')) {
                                        chunk.files.add(cssBundleFilename);
                                        break;
                                    }
                                }
                            }
                        }
                    });
                }
            }
            else if (this.options.cssInjection === 'mini-css') {
                (0, mini_css_support_1.injectCssModules)(webpack, compilation, staticPublicPath, stylableModules, assetsModules);
            }
        }
    }
    setupDependencies({ dependencyTemplates, dependencyFactories }, normalModuleFactory, staticPublicPath, stylableModules, assetsModules) {
        const { StylableRuntimeDependency, InjectDependencyTemplate, CSSURLDependency, NoopTemplate, UnusedDependency, } = this.entities;
        dependencyFactories.set(StylableRuntimeDependency, normalModuleFactory);
        dependencyTemplates.set(StylableRuntimeDependency, new InjectDependencyTemplate(staticPublicPath, stylableModules, assetsModules, this.options.runtimeStylesheetId, this.options.runtimeId, this.options.cssInjection));
        dependencyFactories.set(CSSURLDependency, normalModuleFactory);
        dependencyTemplates.set(CSSURLDependency, new NoopTemplate());
        dependencyFactories.set(UnusedDependency, normalModuleFactory);
        dependencyTemplates.set(UnusedDependency, new NoopTemplate());
    }
}
exports.StylableWebpackPlugin = StylableWebpackPlugin;
const isNormalModule = (module) => {
    return module.resource !== undefined;
};
function isWebpackConfigProcessor(config) {
    return typeof config === 'object' && typeof config.webpackPlugin === 'function';
}
//# sourceMappingURL=plugin.js.map