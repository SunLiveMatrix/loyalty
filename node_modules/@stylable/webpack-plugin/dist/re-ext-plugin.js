"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReExt = void 0;
class ReExt {
    constructor(matchExtRegExp, newExt) {
        this.matchExtRegExp = matchExtRegExp;
        this.newExt = Array.isArray(newExt) ? newExt : [newExt];
    }
    apply(resolver) {
        const target = resolver.ensureHook('file');
        resolver.getHook('raw-file').tapAsync('ReExt', (request, resolveContext, callback) => {
            const relativeFilePath = request.relativePath;
            const requestedPath = request.path;
            const matchExtRegExp = this.matchExtRegExp;
            if (!requestedPath || !relativeFilePath || !relativeFilePath.match(matchExtRegExp)) {
                return callback();
            }
            async function runMatchExt(newExt) {
                for (const ext of newExt) {
                    const resolved = await resolveExt(ext);
                    if (resolved)
                        return resolved;
                }
                return undefined;
            }
            runMatchExt(this.newExt)
                .then((res) => {
                res ? callback(null, res) : callback();
            })
                .catch((err) => {
                callback(err);
            });
            function resolveExt(newExt) {
                return new Promise((res) => {
                    resolver.doResolve(target, {
                        ...request,
                        path: requestedPath.replace(matchExtRegExp, newExt),
                        relativePath: relativeFilePath.replace(matchExtRegExp, newExt),
                    }, `replacing extension for ${relativeFilePath} to ${newExt}`, resolveContext, (err, resolved) => {
                        err ? res(undefined) : res(resolved);
                    });
                });
            }
        });
    }
}
exports.ReExt = ReExt;
//# sourceMappingURL=re-ext-plugin.js.map