"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getWebpackEntities = void 0;
const runtime_1 = require("@stylable/runtime");
const index_internal_1 = require("@stylable/runtime/dist/index-internal");
const plugin_utils_1 = require("./plugin-utils");
const loader_utils_1 = require("./loader-utils");
const entitiesCache = new WeakMap();
function getWebpackEntities(webpack) {
    const { dependencies: { ModuleDependency, HarmonyImportDependency }, Dependency, NormalModule, RuntimeModule, RuntimeGlobals, } = webpack;
    let entities = entitiesCache.get(webpack);
    if (entities) {
        return entities;
    }
    class CSSURLDependency extends ModuleDependency {
        get type() {
            return 'url()';
        }
        get category() {
            return 'url';
        }
    }
    class UnusedDependency extends HarmonyImportDependency {
        constructor() {
            super(...arguments);
            this.weak = true;
        }
        get type() {
            return '@st-unused-import';
        }
        get category() {
            return 'esm';
        }
    }
    class NoopTemplate {
        apply() {
            /** noop */
        }
    }
    class StylableRuntimeStylesheet extends RuntimeModule {
        constructor() {
            super('stylable stylesheet', RuntimeModule.STAGE_NORMAL);
        }
        generate() {
            return `(${runtime_1.stylesheet})(__webpack_require__)`;
        }
    }
    class StylableRuntimeDependency extends Dependency {
        constructor(stylableBuildMeta) {
            super();
            this.stylableBuildMeta = stylableBuildMeta;
        }
        updateHash(hash) {
            hash.update(JSON.stringify(this.stylableBuildMeta));
        }
        serialize(context) {
            context.write(this.stylableBuildMeta);
            super.serialize(context);
        }
    }
    class InjectDependencyTemplate {
        constructor(staticPublicPath, stylableModules, assetsModules, runtimeStylesheetId, runtimeId, cssInjection) {
            this.staticPublicPath = staticPublicPath;
            this.stylableModules = stylableModules;
            this.assetsModules = assetsModules;
            this.runtimeStylesheetId = runtimeStylesheetId;
            this.runtimeId = runtimeId;
            this.cssInjection = cssInjection;
        }
        apply(_dependency, source, { module, runtimeRequirements, runtimeTemplate, moduleGraph, runtime, chunkGraph, dependencyTemplates, }) {
            /**
             * NOTICE: replace assumes changes are done from bottom->top
             * replace out of order might cause issues!
             * the order is coupled with "loader.ts".
             */
            const stylableBuildData = (0, plugin_utils_1.getStylableBuildData)(this.stylableModules, module);
            if (!stylableBuildData.isUsed) {
                return;
            }
            if (this.cssInjection === 'js') {
                const css = (0, plugin_utils_1.replaceMappedCSSAssetPlaceholders)({
                    assetsModules: this.assetsModules,
                    staticPublicPath: this.staticPublicPath,
                    chunkGraph,
                    moduleGraph,
                    dependencyTemplates,
                    runtime,
                    runtimeTemplate,
                    stylableBuildData,
                });
                if (!(module instanceof NormalModule)) {
                    throw new Error(`InjectDependencyTemplate should only be used on stylable modules was found on ${module.identifier()}`);
                }
                const id = this.runtimeStylesheetId === 'module'
                    ? JSON.stringify(runtimeTemplate.requestShortener.contextify(module.resource))
                    : 'namespace';
                replacePlaceholder(source, '/* JS_INJECT */', `__webpack_require__.sti(${id}, ${JSON.stringify(css)}, ${stylableBuildData.depth}, ${JSON.stringify(this.runtimeId)});`);
                runtimeRequirements.add(StylableRuntimeInject.name);
            }
            const usedExports = moduleGraph.getUsedExports(module, runtime);
            if (typeof usedExports === 'boolean') {
                if (usedExports) {
                    runtimeRequirements.add(StylableRuntimeStylesheet.name);
                }
            }
            else if (!usedExports) {
                runtimeRequirements.add(StylableRuntimeStylesheet.name);
            }
            else if (usedExports.has('st') ||
                usedExports.has('style') ||
                usedExports.has('cssStates')) {
                runtimeRequirements.add(StylableRuntimeStylesheet.name);
            }
            if (runtimeRequirements.has(StylableRuntimeStylesheet.name)) {
                /* st */
                replacePlaceholder(source, (0, loader_utils_1.getReplacementToken)('st'), `/*#__PURE__*/ style`);
                /* style */
                replacePlaceholder(source, (0, loader_utils_1.getReplacementToken)('sts'), `/*#__PURE__*/ __webpack_require__.sts.bind(null, namespace)`);
                /* cssStates */
                replacePlaceholder(source, (0, loader_utils_1.getReplacementToken)('stc'), `/*#__PURE__*/ __webpack_require__.stc.bind(null, namespace)`);
            }
            replacePlaceholder(source, (0, loader_utils_1.getReplacementToken)('vars'), JSON.stringify(stylableBuildData.exports.vars));
            replacePlaceholder(source, (0, loader_utils_1.getReplacementToken)('stVars'), JSON.stringify(stylableBuildData.exports.stVars));
            replacePlaceholder(source, (0, loader_utils_1.getReplacementToken)('containers'), JSON.stringify(stylableBuildData.exports.containers));
            replacePlaceholder(source, (0, loader_utils_1.getReplacementToken)('layers'), JSON.stringify(stylableBuildData.exports.layers));
            replacePlaceholder(source, (0, loader_utils_1.getReplacementToken)('keyframes'), JSON.stringify(stylableBuildData.exports.keyframes));
            replacePlaceholder(source, (0, loader_utils_1.getReplacementToken)('classes'), JSON.stringify(stylableBuildData.exports.classes));
            replacePlaceholder(source, (0, loader_utils_1.getReplacementToken)('namespace'), JSON.stringify(stylableBuildData.namespace));
        }
    }
    class StylableRuntimeInject extends RuntimeModule {
        constructor() {
            super('stylable inject', RuntimeModule.STAGE_NORMAL);
        }
        generate() {
            return `(${index_internal_1.injectStyles})(__webpack_require__)`;
        }
    }
    function injectRuntimeModules(name, compilation) {
        compilation.hooks.runtimeRequirementInModule
            .for(StylableRuntimeInject.name)
            .tap(name, (_module, set) => {
            set.add(RuntimeGlobals.require);
        });
        compilation.hooks.runtimeRequirementInModule
            .for(StylableRuntimeStylesheet.name)
            .tap(name, (_module, set) => {
            set.add(RuntimeGlobals.require);
        });
        compilation.hooks.runtimeRequirementInTree
            .for(StylableRuntimeInject.name)
            .tap(name, (chunk, _set) => {
            compilation.addRuntimeModule(chunk, new StylableRuntimeInject());
        });
        compilation.hooks.runtimeRequirementInTree
            .for(StylableRuntimeStylesheet.name)
            .tap(name, (chunk, _set) => {
            compilation.addRuntimeModule(chunk, new StylableRuntimeStylesheet());
        });
    }
    registerSerialization(webpack, StylableRuntimeDependency, (ctx) => [ctx.read()]);
    /* The request is empty for both dependencies and it will be overridden by the de-serialization process */
    registerSerialization(webpack, UnusedDependency, () => ['', 0, undefined]);
    registerSerialization(webpack, CSSURLDependency, () => ['']);
    entities = {
        injectRuntimeModules,
        StylableRuntimeInject,
        InjectDependencyTemplate,
        StylableRuntimeDependency,
        StylableRuntimeStylesheet,
        CSSURLDependency,
        NoopTemplate,
        UnusedDependency,
    };
    entitiesCache.set(webpack, entities);
    return entities;
}
exports.getWebpackEntities = getWebpackEntities;
function replacePlaceholder(source, replacementPoint, value) {
    const i = source.source().indexOf(replacementPoint);
    if (!i) {
        throw new Error(`missing ${replacementPoint} from stylable loader source`);
    }
    source.replace(i, i + replacementPoint.length - 1, value, `${replacementPoint}`);
}
function registerSerialization(webpack, Type, getArgs) {
    webpack.util.serialization.register(Type, __filename, Type.name, {
        serialize(instance, context) {
            instance.serialize(context);
        },
        deserialize(context) {
            const instance = new Type(...getArgs(context));
            instance.deserialize(context);
            return instance;
        },
    });
}
//# sourceMappingURL=webpack-entities.js.map