"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.splitCompoundSelectors = exports.groupCompoundSelectors = void 0;
const walk_1 = require("./walk");
function groupCompoundSelectors(input, options) {
    const context = createCompoundContext(options);
    (0, walk_1.walk)(input, (node, _index, _nodes, parents) => {
        if (parents.length === 0 && node.type === `selector`) {
            // first level: create top level selector
            context.addSelector(node);
        }
        else {
            // second level: (parents.length === 1)
            if (options?.deep && `nodes` in node) {
                // compound nested selectors
                /* This `nodes` type is hard since it's internal we use any[] here. sorry */
                const nodes = [];
                for (const nested of node.nodes) {
                    nodes.push(nested.type === `selector`
                        ? groupCompoundSelectors(nested, options)
                        : nested);
                }
                node = { ...node, nodes };
            }
            context.handleNode(node);
            // don't go deeper - shallow group
            return walk_1.walk.skipNested;
        }
        return;
    });
    return `length` in input ? context.output : context.output[0];
}
exports.groupCompoundSelectors = groupCompoundSelectors;
function createCompoundContext({ splitPseudoElements = true } = {}) {
    const output = [];
    let lastSelector;
    let lastCompound;
    let lastCompoundInitialPart;
    const handleNode = (node) => {
        if (node.type === `pseudo_element` && splitPseudoElements === true) {
            lastCompound = undefined;
        }
        if (node.type === `combinator`) {
            lastSelector.nodes.push(node);
            lastCompound = undefined;
        }
        else if (node.type === `comment` && !isCommentWithNoSpacing(node)) {
            // comment that breaks compound
            lastSelector.nodes.push(node);
            lastCompound = undefined;
        }
        else if (node.type === `type` ||
            node.type === `universal` ||
            node.type === `class` ||
            node.type === `id` ||
            node.type === `attribute` ||
            node.type === `nesting` ||
            node.type === `pseudo_class` ||
            node.type === `pseudo_element` ||
            node.type === `invalid` ||
            node.type === `comment` /*no spacing*/) {
            // part of compound
            if (!lastCompound) {
                // add new compound selector
                lastCompoundInitialPart = undefined;
                lastCompound = {
                    type: `compound_selector`,
                    start: node.start,
                    end: node.end,
                    before: ``,
                    after: ``,
                    nodes: [],
                    invalid: false,
                };
                lastSelector.nodes.push(lastCompound);
            }
            if (!lastCompound.invalid && node.type !== `comment`) {
                // validate compound parts after initial
                if (lastCompoundInitialPart) {
                    lastCompound.invalid = node.type === `universal` || node.type === `type`;
                }
                lastCompoundInitialPart = node;
            }
            lastCompound.nodes.push(node);
            lastCompound.end = node.end;
        }
        else if (node.type === `selector` || node.type === `compound_selector`) {
            // spread
            for (const innerNode of node.nodes) {
                handleNode(innerNode);
            }
        }
        else {
            // handle out of context nodes
            lastSelector.nodes.push(node);
            lastCompound = undefined;
        }
    };
    return {
        addSelector(node) {
            lastSelector = {
                type: `selector`,
                start: node.start,
                end: node.end,
                before: `before` in node ? node.before : ``,
                after: `after` in node ? node.after : ``,
                nodes: [],
            };
            output.push(lastSelector);
            lastCompound = undefined;
        },
        handleNode,
        output,
    };
}
function splitCompoundSelectors(input) {
    const inputSelectors = Array.isArray(input) ? input : [input];
    const output = [];
    for (const inputSelector of inputSelectors) {
        const outputSelector = {
            ...inputSelector,
            nodes: [],
        };
        for (const node of inputSelector.nodes) {
            if (node.type === `compound_selector`) {
                outputSelector.nodes.push(...node.nodes);
            }
            else {
                outputSelector.nodes.push(node);
            }
        }
        output.push(outputSelector);
    }
    return `length` in input ? output : output[0];
}
exports.splitCompoundSelectors = splitCompoundSelectors;
function isCommentWithNoSpacing(node) {
    return node.type === `comment` && node.before === `` && node.after === ``;
}
//# sourceMappingURL=compound.js.map