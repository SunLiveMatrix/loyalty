"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.trimCombinators = exports.ensureSelector = exports.isNamespacedAst = exports.isNamespacedToken = exports.isCombinatorToken = exports.createCommentAst = exports.createCombinatorAst = exports.createEmptyNth = exports.createEmptySelector = void 0;
const core_1 = require("@tokey/core");
// create ast nodes
function createEmptySelector() {
    return {
        type: 'selector',
        start: -1,
        end: -1,
        before: '',
        after: '',
        nodes: [],
    };
}
exports.createEmptySelector = createEmptySelector;
function createEmptyNth() {
    return {
        type: 'nth',
        start: -1,
        end: -1,
        before: '',
        after: '',
        nodes: [],
    };
}
exports.createEmptyNth = createEmptyNth;
function createCombinatorAst({ value, type, start, end, }) {
    return {
        type: `combinator`,
        combinator: type,
        value: type === `space` ? value[0] : value,
        start,
        end,
        before: ``,
        after: type === `space` ? value.slice(1) : ``,
        invalid: false,
    };
}
exports.createCombinatorAst = createCombinatorAst;
function createCommentAst({ value, start, end }) {
    return {
        type: `comment`,
        value,
        start,
        end,
        before: ``,
        after: ``,
    };
}
exports.createCommentAst = createCommentAst;
// type guards
function isCombinatorToken(token) {
    return token.type === 'space' || token.type === '+' || token.type === '>' || token.type === '~';
}
exports.isCombinatorToken = isCombinatorToken;
function isNamespacedToken(token) {
    return token.type === `*` || token.type === `text`;
}
exports.isNamespacedToken = isNamespacedToken;
function isNamespacedAst(token) {
    return token.type === `universal` || token.type === `type`;
}
exports.isNamespacedAst = isNamespacedAst;
// utils
function ensureSelector(selectors, startToken) {
    let lastSelector = (0, core_1.last)(selectors);
    if (!lastSelector) {
        lastSelector = createEmptySelector();
        lastSelector.start = startToken.start;
        selectors.push(lastSelector);
    }
    return lastSelector;
}
exports.ensureSelector = ensureSelector;
function trimCombinators(selector) {
    // costly way to turn combinators to before and after.
    // this can be inlined in the handle token process
    const nodes = selector.nodes;
    const firstNode = nodes[0];
    const lastNode = (0, core_1.last)(nodes);
    // remove first space combinator and add to selector before
    // (going between comment is not required for the start because they are taken care
    // of during parsing)
    if (firstNode?.type === 'combinator' && firstNode.combinator === 'space') {
        selector.nodes.shift();
        selector.before += firstNode.before + firstNode.value + firstNode.after;
    }
    // remove any edge space combinators (last and between comments)
    if (lastNode && lastNode !== firstNode) {
        let index = nodes.length - 1;
        let current = lastNode;
        let lastComment;
        while (current &&
            (current.type === `comment` ||
                (current.type === `combinator` && current.combinator === `space`))) {
            if (current.type === `combinator`) {
                if (!lastComment) {
                    // attach space to end of selector
                    selector.nodes.pop();
                    selector.after += current.before + current.value + current.after;
                }
                else {
                    // attach space to start of comment
                    selector.nodes.splice(index, 1);
                    lastComment.before += current.before + current.value + current.after;
                    lastComment.start = current.start;
                }
            }
            else {
                lastComment = current;
            }
            current = nodes[--index];
        }
    }
}
exports.trimCombinators = trimCombinators;
//# sourceMappingURL=helpers.js.map