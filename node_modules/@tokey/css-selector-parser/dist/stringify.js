"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.stringifySelectorAst = void 0;
const nth_parser_1 = require("./nth-parser");
function stringifySelectorAst(value) {
    return 'length' in value ? stringifySelectors(value) : stringifyNode(value);
}
exports.stringifySelectorAst = stringifySelectorAst;
const printers = {
    id: (node) => `#${node.value}${stringifyNested(node)}`,
    class: (node) => `.${node.dotComments.map(stringifyNode).join('')}${node.value}${stringifyNested(node)}`,
    type: (node) => `${stringifyNamespace(node)}${node.value}${stringifyNested(node)}`,
    combinator: (node) => `${node.before}${node.value}${node.after}`,
    attribute: (node) => `[${node.value}]${stringifyNested(node)}`,
    pseudo_class: (node) => `:${node.colonComments.map(stringifyNode).join('')}${node.value}${stringifyNested(node)}`,
    pseudo_element: (node) => `:${node.colonComments.first.map(stringifyNode).join('')}:${node.colonComments.second
        .map(stringifyNode)
        .join('')}${node.value}${stringifyNested(node)}`,
    comment: ({ before, value, after }) => `${before}${value}${after}`,
    universal: (node) => `${stringifyNamespace(node)}${node.value}${stringifyNested(node)}`,
    nesting: (node) => `${node.value}${stringifyNested(node)}`,
    selector: (node) => `${node.before}${node.nodes.map(stringifyNode).join('')}${node.after}`,
    compound_selector: (node) => `${node.before}${node.nodes.map(stringifyNode).join('')}${node.after}`,
    invalid: (node) => node.value,
    nth: (node) => `${node.before}${node.nodes.map(stringifyNode).join('')}${node.after}`,
    nth_step: ({ before, value, after }) => `${before}${value}${after}`,
    nth_dash: ({ before, value, after }) => `${before}${value}${after}`,
    nth_offset: ({ before, value, after }) => `${before}${value}${after}`,
    nth_of: ({ before, value, after }) => `${before}${value}${after}`,
};
function stringifyNode(node) {
    return printers[node.type]?.(node) ?? '';
}
function stringifySelectors(selectors) {
    const result = [];
    for (const node of selectors) {
        result.push(stringifyNode(node));
    }
    return result.join(`,`);
}
function stringifyNested(node) {
    if ('nodes' in node) {
        if (node.nodes?.length) {
            if (node.type === `pseudo_class` && nth_parser_1.NthParser.isNthPseudoClass(node.value)) {
                const [nthNode, ...selectors] = node.nodes;
                return `(${stringifyNode(nthNode)}${stringifySelectors(selectors)})`;
            }
            else {
                return `(${stringifySelectors(node.nodes)})`;
            }
        }
        else {
            return `()`;
        }
    }
    return '';
}
function stringifyNamespace({ namespace }) {
    let ns = ``;
    if (namespace) {
        ns += namespace.value;
        for (const comment of namespace.beforeComments) {
            ns += printers.comment(comment);
        }
        ns += `|`;
        for (const comment of namespace.afterComments) {
            ns += printers.comment(comment);
        }
    }
    return ns;
}
//# sourceMappingURL=stringify.js.map