import type { CSSValueAST, BuildVarAst } from './ast-types';
import type { ParseResults } from './value-parser';
export declare function defineProperty<FORMATS extends string, CLASSIFICATIONS extends string, TOP_COMMA extends boolean = false>(_config: {
    name: string;
    syntax: string;
    subSyntax?: Record<string, string>;
    subProperties?: Record<string, ReturnType<typeof defineProperty>>;
    topLevelCommaSeparation?: TOP_COMMA;
    formats?: Record<FORMATS, string>;
    classifications?: Record<CLASSIFICATIONS, MatchClassification | (TOP_COMMA extends true ? {
        match?: MatchClassification;
        syntax?: string;
        inTopLevelIndex?: (index: number, total: number) => boolean;
        cssProperty?: ReturnType<typeof defineProperty>;
    } : {
        match?: MatchClassification;
        syntax?: string;
        cssProperty?: ReturnType<typeof defineProperty>;
    })>;
}): {
    validate: (ast: CSSValueAST<any>[], options?: ActionParams) => [...errors: string[]];
    getFormat: (ast: CSSValueAST<any>[], options?: ActionParams) => FORMATS;
    classify: (ast: CSSValueAST<any>[], options?: ActionParams & {
        deep?: boolean;
        ignoreComments?: boolean;
    }) => TOP_COMMA extends true ? Record<CLASSIFICATIONS, Classification>[] : Record<CLASSIFICATIONS, Classification>;
};
export declare namespace defineProperty {
    var errors: {
        unexpectedType: (node: CSSValueAST<any>, expectedType: string) => string;
        unexpectedComma: () => string;
    };
}
export interface ActionParams {
    cssVars?: Record<string, CSSValueAST<any>[]>;
    resolveBuildVar?: (node: BuildVarAst) => CSSValueAST<any>[];
}
type MatchClassification = (node: CSSValueAST<any>, info: {
    index: number;
    indexOfType: number;
    amountOfType: number;
}) => boolean;
type Classification = {
    value: CSSValueAST<any>[];
    resolved: {
        origin: ParseResults;
        nodes: CSSValueAST<any>[];
    }[][];
    isProperty: boolean;
};
export {};
//# sourceMappingURL=define-property.d.ts.map