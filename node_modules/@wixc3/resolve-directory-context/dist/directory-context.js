"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getRootPackage = exports.allPackagesFromContext = exports.childPackagesFromContext = exports.resolveDirectoryContext = void 0;
const workspaces_1 = require("./workspaces");
const language_helpers_1 = require("./language-helpers");
const npm_package_1 = require("./npm-package");
const find_up_1 = require("./find-up");
function resolveDirectoryContext(basePath, host) {
    const packageJsonPath = (0, find_up_1.findFileUpSync)(basePath, npm_package_1.PACKAGE_JSON, host);
    if (!(0, language_helpers_1.isString)(packageJsonPath)) {
        throw new Error(`Cannot find ${npm_package_1.PACKAGE_JSON} for ${basePath}`);
    }
    const directoryPath = host.dirname(packageJsonPath);
    const packageJsonContent = host.readFileSync(packageJsonPath, 'utf8');
    const packageJson = JSON.parse(packageJsonContent);
    if (!(0, language_helpers_1.isPlainObject)(packageJson)) {
        throw new Error(`${packageJsonPath} is not a valid json object.`);
    }
    const displayName = packageJson.name ? packageJson.name : packageJsonPath;
    const rootPackage = {
        displayName,
        directoryPath,
        packageJson,
        packageJsonPath,
        packageJsonContent,
    };
    const { workspaces } = rootPackage.packageJson;
    if (workspaces !== undefined) {
        return {
            type: 'multi',
            rootPackage,
            packages: (0, npm_package_1.sortPackagesByDepth)((0, workspaces_1.resolveWorkspacePackages)(directoryPath, (0, workspaces_1.extractPackageLocations)(packageJson.workspaces), host)),
        };
    }
    const lernaJsonPath = host.join(directoryPath, 'lerna.json');
    if (host.existsSync(lernaJsonPath)) {
        const lernaJsonContents = host.readFileSync(lernaJsonPath, 'utf8');
        const lernaJson = JSON.parse(lernaJsonContents);
        if ((0, language_helpers_1.isPlainObject)(packageJson) && Array.isArray(lernaJson.packages)) {
            return {
                type: 'multi',
                rootPackage,
                packages: (0, npm_package_1.sortPackagesByDepth)((0, workspaces_1.resolveWorkspacePackages)(directoryPath, (0, workspaces_1.extractPackageLocations)(lernaJson.packages), host)),
            };
        }
    }
    const linkedPackages = (0, npm_package_1.resolveLinkedPackages)(rootPackage, host);
    if (linkedPackages.length) {
        return {
            type: 'multi',
            rootPackage,
            packages: (0, npm_package_1.sortPackagesByDepth)(linkedPackages),
        };
    }
    return {
        type: 'single',
        npmPackage: rootPackage,
    };
}
exports.resolveDirectoryContext = resolveDirectoryContext;
function childPackagesFromContext(context) {
    return context.type === 'single' ? [context.npmPackage] : [...context.packages];
}
exports.childPackagesFromContext = childPackagesFromContext;
function allPackagesFromContext(context) {
    return context.type === 'single' ? [context.npmPackage] : [context.rootPackage, ...context.packages];
}
exports.allPackagesFromContext = allPackagesFromContext;
function getRootPackage(context) {
    return context.type === 'single' ? context.npmPackage : context.rootPackage;
}
exports.getRootPackage = getRootPackage;
//# sourceMappingURL=directory-context.js.map