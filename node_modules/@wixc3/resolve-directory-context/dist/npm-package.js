"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sortPackagesByDepth = exports.resolveLinkedPackages = exports.PACKAGE_JSON = void 0;
const language_helpers_1 = require("./language-helpers");
exports.PACKAGE_JSON = 'package.json';
function resolveLinkedPackages(rootPackage, host) {
    const { dependencies = {}, devDependencies = {} } = rootPackage.packageJson;
    const linkedPackages = [];
    for (const request of (0, language_helpers_1.concatIterables)(Object.values(dependencies), Object.values(devDependencies))) {
        if (request === null || request === void 0 ? void 0 : request.startsWith('file:')) {
            const linkTarget = request.slice(5);
            const directoryPath = host.join(rootPackage.directoryPath, linkTarget);
            const packageJsonPath = host.join(directoryPath, exports.PACKAGE_JSON);
            const packageJsonContent = host.readFileSync(packageJsonPath, 'utf8');
            const packageJson = JSON.parse(packageJsonContent);
            if (!(0, language_helpers_1.isPlainObject)(packageJson)) {
                throw new Error(`${packageJsonPath} is not a valid json object.`);
            }
            const displayName = packageJson.name ? packageJson.name : packageJsonPath;
            linkedPackages.push({
                displayName,
                directoryPath,
                packageJson,
                packageJsonPath,
                packageJsonContent,
            });
        }
    }
    return linkedPackages;
}
exports.resolveLinkedPackages = resolveLinkedPackages;
function getDirectDepPackages(npmPackage, packages) {
    const depPackages = new Set();
    for (const depName of getPackageDependencyNames(npmPackage.packageJson)) {
        const depPackage = packages.get(depName);
        if (depPackage && depPackage !== npmPackage) {
            depPackages.add(depPackage);
        }
    }
    return depPackages;
}
function getPackageDependencyNames({ dependencies = {}, devDependencies = {}, peerDependencies = {} }) {
    return new Set([...Object.keys(dependencies), ...Object.keys(devDependencies), ...Object.keys(peerDependencies)]);
}
function sortPackagesByDepth(packages) {
    const namedPackages = new Map();
    for (const npmPackage of packages) {
        const { name: packageName } = npmPackage.packageJson;
        if ((0, language_helpers_1.isString)(packageName)) {
            namedPackages.set(packageName, npmPackage);
        }
    }
    const packageToDeepDeps = new Map(packages.map((npmPackage) => [
        npmPackage,
        (0, language_helpers_1.flattenTree)(npmPackage, (p) => Array.from(getDirectDepPackages(p, namedPackages))),
    ]));
    const sortedPackages = [];
    for (const npmPackage of packages) {
        const dependingPackageIdx = sortedPackages.findIndex((sortedPackage) => packageToDeepDeps.get(sortedPackage).has(npmPackage));
        if (dependingPackageIdx === -1) {
            sortedPackages.push(npmPackage);
        }
        else {
            sortedPackages.splice(dependingPackageIdx, 0, npmPackage);
        }
    }
    return sortedPackages;
}
exports.sortPackagesByDepth = sortPackagesByDepth;
//# sourceMappingURL=npm-package.js.map